<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicon/favicon-16x16.png">
    <link rel="manifest" href="img/favicon/site.webmanifest">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:regular,500,600,700,800,italic&display=swap&subset=cyrillic-ext" rel="stylesheet" /> <!-- .wrapper -->
    <link href="https://fonts.googleapis.com/css?family=Wix+Madefor+Text:regular&display=swap&subset=cyrillic-ext" rel="stylesheet" /> <!-- .nav__list LI:before -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata:regular,500&display=swap&subset=cyrillic-ext" rel="stylesheet" /> <!-- CODE -->
    <title>JavaScript</title>
    <link rel="stylesheet" href="css/myreset.css">
    <link rel="stylesheet" href="css/style.css">
    <script defer src="js/script.js"></script>
</head>
<body>
    <div class="wrapper">
        <header class="header">
            <div class="header__container _container">
                <div class="header__body">
                    <div class="header__logo">
                        Notes
                    </div>
                    <div class="header__menu menu">
                        <div class="menu__burger">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <nav class="menu__body">
                            <ul class="menu__list">
                                <li>
                                    <a href="index.html" class="menu__link _active">JavaScript</a>
                                </li>
                                <li>
                                    <a href="browser.html" class="menu__link">DOM</a>
                                </li>
                                <li>
                                    <a href="canvas.html" class="menu__link">Canvas</a>
                                </li>
                                <li>
                                    <a href="git.html" class="menu__link">Git</a>
                                </li>
                                <li>
                                    <a href="react.html" class="menu__link">React</a>
                                </li>
                            </ul>
                        </nav>
                    </div>
                </div>
            </div>
        </header>
        <main class="page">
            <section class="page__nav nav">
                <div class="nav__container _container">
                    <div class="nav__header header-nav">
                        <h1 class="header-nav__title">JavaScript</h1>
                        <div class="header-nav__description">Краткое изложение основных тем 1 и 3 частей учебника <a target="_blank" href="https://learn.javascript.ru/">learn.javascript.ru</a>.</div>
                    </div>
                    <div class="nav__body">
                        <div class="nav__row">
                            <div class="nav__title">Типы данных</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#data-types-symbol" class="nav__link">Тип данных Symbol</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-object" class="nav__link">Объекты</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-object-toprimitive" class="nav__link">Преобразование объектов в примитивы</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-number" class="nav__link">Числа</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-string" class="nav__link">Строки</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-array" class="nav__link">Массивы</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-iterable" class="nav__link">Перебираемые объекты</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-map-set" class="nav__link">Map, Set, WeakMap, WeakSet</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-destructuring-assignment" class="nav__link">Деструктурирующее присваивание</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-date" class="nav__link">Дата и время</a>
                                    </li>
                                    <li>
                                        <a href="#data-types-json" class="nav__link">Формат JSON, метод toJSON</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Продвинутая работа с функциями</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#advanced-functions-rest-spread" class="nav__link">Остаточные параметры и spead оператор</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-closure" class="nav__link">Область видимости переменных, замыкание</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-var-global" class="nav__link">"var" и глобальный объект</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-function-object" class="nav__link">Объект функции, NFE</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-new-function-eval" class="nav__link">"new Function" и eval</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-settimeout-setinterval" class="nav__link">Планирование: setTimeout и setInterval</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-call-apply" class="nav__link">Декораторы и переадресация вызова, call/apply</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-bind" class="nav__link">Привязка контекста к функции</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-currying" class="nav__link">Каррирование</a>
                                    </li>
                                    <li>
                                        <a href="#advanced-functions-arrow-functions" class="nav__link">Стрелочные функции</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Регулярные выражения</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#regexp-introduction" class="nav__link">Шаблоны, флаги, якоря</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-classes" class="nav__link">Символьные классы</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-unicode" class="nav__link">Юникод: флаг "u" и класс \p{...}</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-escaping" class="nav__link">Экранирование, специальные символы</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-sets-and-ranges" class="nav__link">Наборы и диапазоны [...]</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-quantifiers" class="nav__link">Квантификаторы +, *, ? и {n}</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-greedy-and-lazy" class="nav__link">Жадные и ленивые квантификаторы</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-groups" class="nav__link">Скобочные группы</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-backreferences" class="nav__link">Обратные ссылки в шаблоне: \N и \k&lt;имя></a>
                                    </li>
                                    <li>
                                        <a href="#regexp-alternation" class="nav__link">Альтернация (или) |</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-lookahead-lookbehind" class="nav__link">Опережающие и ретроспективные проверки</a>
                                    </li>
                                    <li>
                                        <a href="#regexp-sticky" class="nav__link">Поиск на заданной позиции, флаг "y"</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Свойства объекта, их конфигурация</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#property-descriptors" class="nav__link">Флаги и дескрипторы свойств</a>
                                    </li>
                                    <li>
                                        <a href="#property-accessors" class="nav__link">Свойства - геттеры и сеттеры</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Прототипы, наследование</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#proto-inheritance" class="nav__link">Прототипное наследование</a>
                                    </li>
                                    <li>
                                        <a href="#proto-function-prototype" class="nav__link">F.prototype</a>
                                    </li>
                                    <li>
                                        <a href="#proto-native-prototypes" class="nav__link">Встроенные прототипы</a>
                                    </li>
                                    <li>
                                        <a href="#proto-methods" class="nav__link">Методы прототипов, объекты без __proto__</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Классы</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#class-syntax" class="nav__link">Класс: базовый синтаксис</a>
                                    </li>
                                    <li>
                                        <a href="#class-inheritance" class="nav__link">Наследование классов</a>
                                    </li>
                                    <li>
                                        <a href="#class-static" class="nav__link">Статические свойства и методы</a>
                                    </li>
                                    <li>
                                        <a href="#class-private" class="nav__link">Приватные методы и свойства</a>
                                    </li>
                                    <li>
                                        <a href="#class-extend-natives" class="nav__link">Расширение встроенных классов</a>
                                    </li>
                                    <li>
                                        <a href="#class-instanceof" class="nav__link">Проверка класса: "instanceof"</a>
                                    </li>
                                    <li>
                                        <a href="#class-mixins" class="nav__link">Примеси</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Обработка ошибок</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#try-catch" class="nav__link">Обработка ошибок, "try..catch"</a>
                                    </li>
                                    <li>
                                        <a href="#custom-errors" class="nav__link">Пользовательские ошибки, расширение Error</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Промисы, async/await</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#promise-basics" class="nav__link">Промисы</a>
                                    </li>
                                    <li>
                                        <a href="#promise-chaining" class="nav__link">Цепочка промисов</a>
                                    </li>
                                    <li>
                                        <a href="#promise-error-handling" class="nav__link">Промисы: обработка ошибок</a>
                                    </li>
                                    <li>
                                        <a href="#promise-api" class="nav__link">Promise API</a>
                                    </li>
                                    <li>
                                        <a href="#promise-async-await" class="nav__link">Async/await</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Генераторы, продвинутая итерация</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#generators" class="nav__link">Генераторы</a>
                                    </li>
                                    <li>
                                        <a href="#generators-async-iterators" class="nav__link">Асинхронные итераторы и генераторы</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Модули</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#modules-intro" class="nav__link">Модули, введение</a>
                                    </li>
                                    <li>
                                        <a href="#modules-import-export" class="nav__link">Экспорт и импорт</a>
                                    </li>
                                    <li>
                                        <a href="#modules-dynamic-imports" class="nav__link">Динамические импорты</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="nav__row">
                            <div class="nav__title">Разное</div>
                            <nav class="nav__content">
                                <ul class="nav__list">
                                    <li>
                                        <a href="#proxy" class="nav__link">Proxy и Reflect</a>
                                    </li>
                                    <li>
                                        <a href="#bitwise-operators" class="nav__link">Побитовые операторы</a>
                                    </li>
                                    <li>
                                        <a href="#bigint" class="nav__link">BigInt</a>
                                    </li>
                                    <li>
                                        <a href="#intl" class="nav__link">Intl: интернационализация в JavaScript</a>
                                    </li>
                                    <li>
                                        <a href="#binary" class="nav__link">Бинарные данные и файлы</a>
                                    </li>
                                    <li>
                                        <a href="#fetch" class="nav__link">Fetch</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                    </div>
                </div>
            </section>
            <div class="page__content content">
                <div class="content__container _container">
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Типы данных</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-symbol" class="chapter__title">Тип данных Symbol</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Символы нужны для создания уникальных идентификаторов. Использование:</p>
                                    <ol>
                                        <li>«Скрытые» свойства объектов.</li>
                                        <li>Системные символолы, доступные как <code>Symbol.*</code> , например:
                                            <ul>
                                                <li>
                                                    <code>Symbol.isConcatSpreadable</code>
                                                </li>
                                                <li>
                                                    <code>Symbol.iterator</code>
                                                </li>
                                                <li>
                                                    <code>Symbol.toPrimitive</code>
                                                </li>
                                            </ul>
                                        </li>
                                    </ol>
                                    <p>Синтаксис:</p>
                                    <p><code>let id = Symbol("id"); // Символ с описанием (именем) "id"</code></p>
<code class="large">let user = {
    [id]: 12,
};
user[id] = 123;</code>
                                    <p>Символы уникальны (не равны друг другу), даже если имеют одинаковое описание.</p>
                                    <p>Для любых символов доступно свойство description:</p>
                                    <p><code>id.description; // id</code></p>
                                    <p>Символы игнорируются циклом <code>for…in</code></p>
                                    <p>Символы не преобразуются автоматически в строки:</p>
                                    <p><code>alert(id); // TypeError: Cannot convert a Symbol value to a string</code></p>
                                    <p>Методы для получения символов:</p>
                                    <ul>
                                        <li><code>Object.getOwnPropertySymbols(obj)</code> возвращает массив символьных ключей объекта</li>
                                        <li><code>Reflect.ownKeys(obj)</code> возвращает массив всех собственных ключей объекта, включая символьные</li>
                                    </ul>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-object" class="chapter__title">Объекты</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>"key" in object // оператор "in" определяет существование свойста</code></p>
                                    <p>Глубокое клонирование объектов можно осуществить с помощью рекурсии, воспользовавшись глобальным методом <code>structuredClone(obj)</code> (поддерживается только современными браузерами), либо использовать метод <code>_.cloneDeep(obj)</code> из JavaScript-библиотеки lodash.</p>
                                    <h4>Получение свойств объекта</h4>
                                    <p><code>Object.getOwnPropertyNames(obj)</code> возвращает не-символьные ключи.</p>
                                    <p><code>Object.getOwnPropertySymbols(obj)</code> возвращает символьные ключи.</p>
                                    <p><code>Object.keys/values()</code> возвращают не-символьные ключи/значения с флагом <code>enumerable</code>.</p>
                                    <p><code>for..in</code> перебирает не-символьные ключи с флагом <code>enumerable</code>, а также ключи прототипов.</p>
                                    <p><code>Reflect.ownKeys(obj)</code> возвращает все собственные ключи объекта, включая символьные.</p>
                                    <h4>Сборка мусора</h4>
                                    <p>Основной алгоритм сборки мусора – «алгоритм пометок» («mark-and-sweep»).</p>
                                    <ul>
                                        <li>Сборщик мусора «помечает» (запоминает) все корневые объекты.</li>
                                        <li>Затем он идёт по их ссылкам и помечает все найденные объекты.</li>
                                        <li>Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.</li>
                                        <li>…И так далее, пока не будут посещены все достижимые (из корней) ссылки.</li>
                                        <li>Все непомеченные объекты удаляются.</li>
                                    </ul>
                                    <h4>"this"</h4>
                                    <p>В JavaScript <code>this</code> является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а зависит от того, какой объект вызывает метод (какой объект стоит «перед точкой»).</p>
                                    <p>Вызов функции без объекта означает, что <code>this === undefined</code>.</p>
                                    <p>Значение <code>this</code> передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки <code>obj.method()</code>. При любой другой операции, например, присваивании <code>obj = obj.method</code>, <code>this</code> теряется и дальнейший вызов происходит уже без <code>this</code>.</p>
<code class="large">let user = { 
    age: 20, 
    f1() { return this.age; }, 
    f2() { return 1; } 
};
(user.age == 20 ? user.f1 : user.f2)(); // TypeError: Cannot read properties of undefined</code>
                                    <h4>Конструкторы, создание объектов через "new"</h4>
                                    <p>Конструкторы следует вызывать при помощи оператора <code>new</code>. Он обработает все случаи преобразований к примитивам.</p>
                                    <p>Такой вызов создаёт пустой <code>this</code> в начале выполнения и возвращает заполненный в конце.</p>
                                    <p>Когда функция вызывается как <code>new User(...)</code>, происходит следующее:</p>
                                    <ol>
                                        <li>Создаётся новый пустой объект, и он присваивается <code>this</code> // <code>this = {};</code> (неявно).</li>
                                        <li>Выполняется код функции. Обычно он модифицирует <code>this</code>, добавляет туда новые свойства.</li>
                                        <li>Возвращается значение <code>this</code> // <code>return this;</code> (неявно).</li>
                                    </ol>
                                    <p>Если функция-конструктор возвращает примитивное значение, то оно будет отброшено.</p>
                                    <p>Если же возвращаемое значение - объект, то вместо <code>this</code> будет возвращён этот объект.</p>
                                    <h5>Проверка на вызов в режиме конструктора: new.target</h5>
                                    <p>В случае обычного вызова функции <code>new.target === undefined</code>. Если же она была вызвана при помощи <code>new</code>, <code>new.target</code> будет равен самой функции.</p>
<code class="large">function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }
  this.name = name;
}</code>
                                    <h4>Опциональная цепочка</h4>
                                    <p>Опциональная цепочка <code>?.</code> останавливает вычисление и возвращает <code>undefined</code>, если часть перед <code>?.</code> имеет значение <code>undefined</code> или <code>null</code>.</p>
                                    <p><code>{}.address.street // TypeError: Cannot read properties of undefined (reading 'street')</code></p>
                                    <p><code>{}.address?.street // undefined (без ошибки)</code></p>
                                    <p>Переменная перед <code>?.</code> должна быть объявлена, иначе выражение выдаст ошибку.</p>
                                    <p>Другие варианты применения: <code>?.()</code>, <code>?.[]</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-object-toprimitive" class="chapter__title">Преобразование объектов в примитивы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Существует "три хинта", то есть 3 варианта преобразования объекта в примитив: <code>"string"</code>, <code>"number"</code>, <code>"default"</code>.</p>
                                    <p>На практике все объекты кроме Date реализуют <code>"default"</code> так же, как и <code>"number"</code>.</p>
                                    <p>В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:</p>
                                    <ul>
                                        <li><code>obj[Symbol.toPrimitive](hint)</code></li>
                                        <li><code>obj.toString()</code></li>
                                        <li><code>obj.valueOf()</code></li>
                                    </ul>
                                    <p>Порядок вызова:</p>
                                    <ol>
                                        <li>Вызывает <code>obj[Symbol.toPrimitive](hint)</code> если такой метод существует, и передаёт ему хинт.</li>
                                        <li>Иначе, если хинт равен <code>"string"</code><br>
                                            пытается вызвать <code>obj.toString()</code>, а если его нет, то <code>obj.valueOf()</code>, если он существует.</li>
                                        <li>В случае, если хинт равен <code>"number"</code> или <code>"default"</code><br>
                                            пытается вызвать <code>obj.valueOf()</code>, а если его нет, то <code>obj.toString()</code>, если он существует.</li>
                                    </ol>
                                    <p><code>Symbol.toPrimitive</code> - это универсальный подход:</p>
                                    <code class="large">let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
        return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
};

alert(user); // {name: "John"} -> hint: string
alert(+user); // 1000 -> hint: number
alert(user + 500); // 1500 -> hint: default</code>
                                    <p>На практике довольно часто достаточно реализовать только <code>obj.toString()</code>.</p>
                                    <p>Он обработает все случаи преобразований к примитивам.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-number" class="chapter__title">Числа</h3>
                                </div>
                                <div class="chapter__content">
                                   <p><code>Number.isInteger(num)</code> возвращает <code>true</code>, если <code>num</code> - целое число, иначе <code>false</code>.</p>
                                   <p><code>num.toFixed(n)</code> округляет число до <code>n</code> знаков после запятой и возвращает строковое представление результата.</p>
                                   <code class="large">let num = 1.396;
num.toFixed(2) === '1.40';</code>
                                    <h5>Шестнадцатеричные, двоичные и восьмеричные числа:</h5>
                                    <p>0x - 16-ые, 0b - 2-ые, 0o - 8-ые.</p>
                                    <code class="large">0xff === 255;
0b1111 === 15;</code>
                                    <p>Метод <code>num.toString(base)</code> возвращает строковое представление числа в системе счисления <code>base</code>, где <code>base</code> от 2 до 36.</p>
                                    <code class="large">20..toString(2) === '10100'; // 2 точки для вызова метода
(20).toString(2) === '10100'; // либо круглые скобки</code>
                                    <h4>Неточные вычисления</h4>
                                    <code class="large">0.1 + 0.2 == 0.3; // false</code>
                                    <p>Число хранится в памяти в бинарной форме.</p>
                                    <p>Дроби, такие как 0.1 и 0.2 являются бесконечной дробью в двоичной форме.</p>
                                    <p>В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, так же, как нет возможности хранить одну третью в десятичной системе счисления.</p>
                                    <p>Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Eсли 52 бит не хватает на цифры, то при записи пропадут младшие разряды.</p>
                                    <code class="large">9999999999999999 === 1e16; // true</code>
                                    <h4>Проверка: isFinite и isNaN</h4>
                                    <p>Значение <code>NaN</code> уникально тем, что оно не равно ничему, даже самому себе.</p>
                                    <code class="large">NaN == NaN; // false</code>
                                    <p><code>isNaN(value)</code> преобразует значение в число и проверяет является ли оно <code>NaN</code>.</p>
                                    <p><code>isFinite(value)</code> преобразует значение в число и возвращает <code>true</code>, если оно не <code>NaN</code>/<code>Infinity</code>/<code>-Infinity</code>.</p>
                                    <p><code>Number.isNaN(value)</code> возвращает <code>true</code> в случае, если значение принадлежит к типу <code>number</code> и является <code>NaN</code> (без преобразования типа).</p>
                                    <p><code>Number.isFinite(value)</code> возвращает <code>true</code> в случае, если значение принадлежит к типу <code>number</code> и не является <code>NaN</code>/<code>Infinity</code>/<code>-Infinity</code> (без преобразования типа).</p>
                                    <p><code>Object.is(a, b)</code> проверяет на строгое равенство, может работать с <code>NaN</code> и нулем.</p>
                                    <code class="large">Object.is(NaN, NaN) === true;
Object.is(-0, 0) === false; // технически эти значения разные</code>
                                    <h4>parseInt и parseFloat</h4>
                                    <p><code>parseInt(str, base)</code> и <code>parseFloat(str)</code> «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Eсли первый символ - не число, возвращают <code>NaN</code>.</p>
                                    <p><code>parseInt</code> возвращает целое число, второй параметр определяет систему счисления (от 2 до 36).</p>
                                    <p><code>parseFloat</code> возвращает число с плавающей точкой.</p>
                                    <code class="large">parseInt('100px') === 100
parseFloat('12.5em') === 12.5
parseFloat('12.3.4') === 12.3
parseInt('2n9c', 36) === 123456</code>
                                    <h4>Методы Math.*</h4>
                                    <p><code>Math.floor(num)</code> - округляет в меньшую сторону</p>
                                    <p><code>Math.ceil(num)</code> - округляет в большую сторону</p>
                                    <p><code>Math.round(num)</code> - округляет до ближайшего целого</p>
                                    <p><code>Math.trunc(num)</code> - удаляет дробную часть без округления</p>
                                    <p><code>Math.abs(num)</code> - возвращает число по модулю</p>
                                    <p><code>Math.random()</code> - возвращает псевдослучайное число n, <code>0 &lt;= n &lt; 1</code></p>
                                    <p><code>Math.max(...nums)</code> - возвращает наибольшее число</p>
                                    <p><code>Math.min(...nums)</code> - возвращает наименьшее число</p>
                                    <p><code>Math.pow(n, power)</code> - возвращает число n, возведённое в степень power</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-string" class="chapter__title">Строки</h3>
                                </div>
                                <div class="chapter__content">
                                    <h5>Спецсимволы</h5>
                                    <ul>
                                        <li><code>\n</code> - перевод строки</li>
                                        <li><code>\t</code> - знак табуляции</li>
                                        <li><code>\'</code>, <code>\"</code> - кавычки</li>
                                        <li><code>\\</code> - обратный слеш ( <code>\</code> )</li>
                                    </ul>
                                    <p>JavaScript позволяет вставить символ в строку, указав его шестнадцатеричный Юникод с помощью одной из трех нотаций:</p>
                                    <ol>
                                        <li><code>\xXX</code> – можно использовать только для первых 256 символов Юникода</li>
                                        <li><code>\uXXXX</code> – кодировка одного из первых 65536 символов Юникода</li>
                                        <li><code>\u{X…XXXXX}</code> – любой символ от 0 до 10FFFF</li>
                                    </ol>
                                    <code class="large">"\xA9" === "©";
"\u{1F680}" === "🚀";</code>
                                    <h4>Основные методы</h4>
                                    <p><code>str.charAt(pos)</code>, <code>str.at(pos)</code> - возвращают символ на позиции pos, при отсутствии возвращают пустую строку.</p>
                                    <p>Если <code>str.at(pos)</code> задать отрицательное число, то отсчет ведется от конца строки.</p>
                                    <code class="large">"Hello".at(-1) === "o";</code>
                                    <p><code>str.toLowerCase()</code> и <code>str.toUpperCase()</code> возвращают строку в заданном регистре.</p>
                                    <p><code>str.indexOf(substr, pos)</code> ищет подстроку <code>substr</code> в строке <code>str</code>, начиная с позиции <code>pos</code>, и возвращает позицию совпадения, либо <code>-1</code> при отсутствии совпадений.</p>
                                    <p><code>str.lastIndexOf(substr, pos)</code> ищет с конца строки (или с <code>pos</code>) до начала.</p>
                                    <code class="large">"some string".indexOf("s", 1) === 5;
"some string".lastIndexOf("s") === 5;</code>
                                    <p><code>str.includes(substr, pos)</code> возвращает <code>true</code>, если в строке <code>str</code> есть подстрока <code>substr</code>, либо <code>false</code>, если нет.</p>
                                    <code class="large">"Midget".includes("id", 2) === false; // поиск начат с позиции 2</code>
                                    <p><code>str.startsWith(substr)</code> и <code>str.endsWith(substr)</code> проверяют, начинается ли и заканчивается ли строка определённой строкой.</p>
                                    <code class="large">"Widget".startsWith("Wid") === true;</code>
                                    <p><code>str.slice(start, end)</code> возвращает часть строки от <code>start</code> до (не включая) <code>end</code>.</p>
                                    <code class="large">"stringify".slice(0, 5) === "strin";
"stringify".slice(2) === "ringify";
"stringify".slice(-4, -1) === "gif";</code>
                                    <p><code>str.substring(start, end)</code> - почти такой же. Можно задавать <code>start</code> больше <code>end</code>, отрицательные значения интерпретируются как <code>0</code>.</p>
                                    <code class="large">"stringify".substring(6, 2) === "ring";
"stringify".substring(2, -3) === "st";</code>
                                    <p><code>str.split(regexp|delim, limit)</code> - разбивает строку на массив по заданному разделителю <code>delim</code>. Если <code>delim</code> не указан, возвращает всю строку в первом элементе массива.</p>
                                    <p>Имеет необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен.</p>
                                    <code class="large">"12345".split('', 2); // ['1', '2']</code>
                                    <p><code>str.trim()</code> — убирает пробелы в начале и конце строки</p>
                                    <p><code>str.repeat(n)</code> — повторяет строку <code>n</code> раз</p>
                                    <h4>Стравнение строк</h4>
                                    <p>Строки кодируются в UTF-16. У любого символа есть соответствующий код.</p>
                                    <p><code>str.codePointAt(pos)</code> возвращает код для символа, находящегося на позиции <code>pos</code>.</p>
                                    <code class="large">"z".codePointAt(0) === 122;
"a".codePointAt() === 97; // pos === 0 при отсутсвии аргумента
"Z".codePointAt(0) === 90;</code>
                                    <p><code>String.fromCodePoint(code)</code> создаёт символ по его коду <code>code</code>.</p>
                                    <code class="large">String.fromCodePoint(90) === "Z"</code>
                                    <p><code>str.codePointAt(pos)</code> и <code>String.fromCodePoint(code)</code> правильно обрабатывают суррогатные пары.</p>
                                    <code class="large">'𝒳'.codePointAt(0) === 119987;
"\u{1d4b3}" === '𝒳'; // (119987).toString(16) === "1d4b3"
String.fromCodePoint(119987) === '𝒳';</code>
                                    <p><code>str.localeCompare(str2)</code> показывает, какая строка больше в соответствии с правилами языка.</p>
                                    <p>Возвращает <code>1</code> если <code>str</code> больше <code>str2</code>, <code>-1</code> если <code>str</code> меньше, <code>0</code> если строки равны.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-array" class="chapter__title">Массивы</h3>
                                </div>
                                <div class="chapter__content">
                                   <code class="large">let arr = new Array(); // эквивалентно let arr = [];
new Array("Яблоко", "Груша", "и тд"); // можно сразу добавить элементы</code>
                                   <p>Однако, если <code>new Array</code> вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.</p>
                                   <h4>Методы</h4>
                                   <p><code>arr.at(pos)</code> - возвращает элемент на позиции <code>pos</code>, <code>pos</code> может быть отрицательным.</p>
                                   <code class="large">[1, 2, 3].at(-1) === 3</code>
                                   <p><code>arr.pop()</code> - удаляет последний элемент из массива и возвращает его.</p>
                                   <p><code>arr.push(elem1, elem2...)</code> - добавляет элемент (или несколько элементов) в конец массива и возвращает длину получившегося массива.</p>
                                   <p><code>arr.shift()</code> - удаляет из массива первый элемент и возвращает его.</p>
                                   <p><code>arr.unshift(elem1, elem2...)</code> - добавляет элемент (или несколько элементов) в начало массива и возвращает длину получившегося массива.</p>
                                   <p><code>arr.splice(index[, deleteCount, elem1, ..., elemN])</code> - удаляет <code>deleteCount</code> элементов начиная с <code>index</code> и заменяет на <code>elemN</code> эл-ты. Возвращает массив удаленных элементов. Может вставлять элементы без удаления если установить <code>deleteCount</code> в <code>0</code>.</p>
                                   <p><code>arr.slice(start, end)</code> - возвращает новый массив, в который копирует элементы, начиная с индекса <code>start</code> и до (не включая) <code>end</code>. Без аргументов создаёт копию массива <code>arr</code>.</p>
                                   <p><code>arr.concat(arg1, arg2...)</code> - создаёт новый массив, в который распаковывает данные из других массивов и добавляет дополнительные значения. Другие объекты добавляются как есть.</p>
                                   <p>Если псевдомассив имеет специальное свойство <code>Symbol.isConcatSpreadable</code> со значением <code>truthy</code>, он обрабатывается как массив.</p>
                                   <code class="large">[1, 2].concat([[3, 4], 5], 6, {7: 8}) // вернет [1, 2, [3, 4], 5, 6, {7: 8}]</code>
                                   <p><code>arr.forEach(function(item, index, array) {...})</code> - позволяет запускать функцию для каждого элемента массива. Результат функции, если она что-то возвращает, игнорируется.</p>
                                   <p><code>arr.indexOf(item, from)</code> - ищет <code>item</code> в массиве, начиная с позиции <code>from</code> и возвращает индекс найденного элемента, либо <code>-1</code> если ничего не найдено.</p>
                                   <p><code>arr.lastIndexOf(item, from)</code> - поиск выполняется начиная с <code>from</code> и заканчивая началом массива.</p>
                                   <p><code>arr.includes(item, from)</code> - ищет <code>item</code> начиная с индекса <code>from</code> и возвращает <code>true</code>, если поиск успешен, <code>false</code> в противном случае. Метод правильно обрабатывает <code>NaN</code>.</p>
                                   <code class="large">[NaN].includes(NaN) === true</code>
                                   <p><code>arr.find(function(item, index, array) {...})</code> - возвращает <code>item</code>, при котором функция вернула <code>truthy</code>, иначе <code>undefined</code>.</p>
                                   <p><code>arr.findIndex(function(item, index, array) {...})</code> - возвращает индекс, при котором функция вернула <code>truthy</code>, иначе <code>-1</code>.</p>
                                   <p><code>arr.filter(function(item, index, array) {...})</code> - возвращает массив из всех подходящих элементов (для которых функция вернула <code>truthy</code>). Возвращается пустой массив в случае, если таких элементов нет.</p>
                                   <p><code>arr.map(function(item, index, array) {...})</code> - вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.</p>
                                   <code class="large">["Bilbo", "Gandalf", "Nazgul"].map(item => item.length) // [5, 7, 6]</code>
                                   <p><code>arr.sort(fn)</code> - возвращает отсортированный массив (возвращенный массив и есть <code>arr</code>).</p>
                                   <p>По умолчанию эл-ты сортируются как строки. Чтобы использовать собственный порядок сортировки, нужно предоставить функцию <code>fn</code> в качестве аргумента.</p>
                                   <p>Эта функция принимает два параметра, назовем их <code>a</code> и <code>b</code> (<code>a</code> - элемент справа). Если функция сравнения этих двух элементов возвращает отрицательное число, элементы меняются местами.</p>
                                   <code class="large">[2, 3, 1].sort( (a, b) => a - b ); // [1, 2, 3]
['Österreich', 'Andorra', 'Vietnam'].sort( (a, b) => a.localeCompare(b) ); // правильная сортировка строк</code>
                                   <p><code>arr.reverse()</code> - меняет порядок элементов в <code>arr</code> на обратный (возвращенный массив и есть <code>arr</code>).</p>
                                   <p><code>arr.join(glue)</code> - возвращает строку из элементов <code>arr</code>, вставляя <code>glue</code> между ними (запятую если <code>glue</code> не указан).</p>
                                   <p><code>arr.reduce(function(previousValue, item, index, array) {...}, [initial])</code> - используется для вычисления единого значения на основе всего массива.</p>
                                   <ul>
                                        <li>метод перебирает массив</li>
                                        <li>при вызове функции результат её вызова передается в <code>previousValue</code></li>
                                        <li>первоначально <code>previousValue</code> берется из <code>initial</code></li>
                                        <li>метод возвращает результат конечной функции</li>
                                   </ul>
                                   <p>Если массив пустой, то возвращается <code>initial</code>, иначе, если не указан <code>initial</code>, вызов завершается ошибкой <code>TypeError: Reduce of empty array with no initial value</code>.</p>
                                   <p><code>arr.reduceRight(function(previousValue, item, index, array) {...}, [initial])</code> - работает аналогично, проходя по массиву справа налево.</p>
                                   <p><code>Array.isArray</code> - используется чтобы отличить простой объект от массива</p>
                                   <code class="large">Array.isArray([]) === true</code>
                                   <h4>«thisArg»</h4>
                                   <code class="large">arr[method](func, thisArg)</code>
                                   <p>Почти все методы массива, которые вызывают функции, за исключением <code>sort</code> и <code>reduce</code>, принимают необязательный параметр <code>thisArg</code>. Значение параметра <code>thisArg</code> становится <code>this</code> для <code>func</code>.</p>
                                   <code class="large">let army = {
    minAge: 18,
    maxAge: 27,
    canJoin(user) {
        return user.age >= this.minAge && user.age &lt; this.maxAge;
    }
};
let users = [{age: 16}, {age: 20}, {age: 23}];
users.filter(army.canJoin, army); // [{age: 20}, {age: 23}]</code>
                                   <h4>Другие методы</h4>
                                   <p><code>arr.some(fn)</code> и <code>arr.every(fn)</code> проверяют массив. Функция <code>fn</code> вызывается для каждого элемента массива. Если какие-либо/все результаты вызовов являются <code>truthy</code>, то метод возвращает <code>true</code>, иначе <code>false</code>.</p>
                                   <p><code>arr.fill(value, start, end)</code> – заполняет массив повторяющимися <code>value</code>, начиная с индекса <code>start</code> до <code>end</code>. Меняет только уже существующие элементы (возвращенный массив и есть <code>arr</code>).</p>
                                   <p><code>arr.copyWithin(target, start, end)</code> – копирует свои элементы, начиная со <code>start</code> и заканчивая <code>end</code>, на позиции, начиная с <code>target</code> (возвращенный массив и есть <code>arr</code>).</p>
                                   <p><code>arr.flat(depth)</code> - создаёт новый массив из всех подмассивов в нём. Он принимает один параметр — глубину «сглаживания» массива.</p>
                                   <code class="large">[1, [2, [3, [4]], 5]].flat(1); // [1, 2, [3, [4]], 5];
[1, [2, [3, [4]], 5]].flat(Infinity); // [1, 2, 3, 4, 5];</code>
                                   <p><code>arr.flatMap(fn)</code> - сначала он вызывает mapping-функцию <code>fn</code> для каждого элемента в массиве, а потом «выравнивает» их в один массив.</p>
                                   <code class="large">['Это предложение', 'Это другое предложение'].flatMap(sentence => sentence.split(' ')) // ['Это', 'предложение', 'Это', 'другое', 'предложение']</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-iterable" class="chapter__title">Перебираемые объекты</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Итерируемые объекты – объекты, которые реализуют метод <code>Symbol.iterator</code>.</p>
                                    <p>Псевдомассивы – объекты, у которых есть индексы и свойство <code>length</code>.</p>
                                    <h4>Symbol.iterator</h4>
                                    <p>Чтобы сделать объект итерируемым (и позволить <code>for..of</code> работать с ним), нужно добавить в объект метод с именем <code>Symbol.iterator</code>.</p>
                                    <ol>
                                        <li>Когда цикл <code>for..of</code> запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом <code>next</code>.</li>
                                        <li>Дальше <code>for..of</code> работает только с этим возвращённым объектом.</li>
                                        <li>Когда <code>for..of</code> хочет получить следующее значение, он вызывает метод <code>next()</code> этого объекта.</li>
                                        <li>Результат вызова <code>next()</code> должен иметь вид <code>{done: Boolean, value: any}</code>, где <code>done: true</code> означает, что итерация закончена, в противном случае <code>value</code> содержит очередное значение.</li>
                                    </ol>
                                    <code class="large">let range = {
    from: 1,
    to: 5
};

range[Symbol.iterator] = function() {
    return {
        current: this.from,
        last: this.to,
    
        next() {
            if (this.current &lt;= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            }
        }
    };
};

for (let num of range) {
    console.log(num); // 1, затем 2, 3, 4, 5
}</code>
                                    <h4>Array.from</h4>
                                    <p><code>Array.from(obj[, mapFn, thisArg])</code> принимает итерируемый объект или псевдомассив и делает из него «настоящий» <code>Array</code>. Позволяет указать необязательную «трансформирующую» функцию.</p>
                                    <code class="large">Array.from(range, num => num * num); // [1, 4, 9, 16, 25] (range взят из примера выше)</code>
                                    <h4>Object.keys, values, entries</h4>
                                    <p><code>Object.keys(obj)</code> – возвращает массив ключей.</p>
                                    <p><code>Object.values(obj)</code> – возвращает массив значений.</p>
                                    <p><code>Object.entries(obj)</code> – возвращает массив пар [ключ, значение].</p>
                                    <p><code>Object.fromEntries(arr)</code> - обратный метод. Преобразует массив пар [ключ, значение] в объект.</p>
                                    <code class="large">Object.fromEntries( Object.entries( {a: 1, b: 2} ).map(([key, value]) => [key, value * 2]) ); // {a: 2, b: 4}</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-map-set" class="chapter__title">Map, Set, WeakMap, WeakSet</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Map</h4>
                                    <p><code>Map</code> – это коллекция пар ключ/значение, как и <code>Object</code>. Позволяет использовать ключи любого типа.</p>
                                    <p>При создании <code>Map</code> можно указать массив (или другой итерируемый объект) с парами ключ-значение.</p>
                                    <code class="large">new Map([
    ['1',  'str1'],
    [1,    'num1'],
    [true, 'bool1']
]); // создает коллекцию из трех пар [ключ, значение]</code>
                                    <p><code>map.set(key, value)</code> – записывает по ключу <code>key</code> значение <code>value</code>. Возвращает получившийся <code>map</code>.</p>
                                    <p><code>map.get(key)</code> – возвращает значение по ключу или <code>undefined</code>, если ключ <code>key</code> отсутствует.</p>
                                    <p><code>map.has(key)</code> – возвращает <code>true</code>, если ключ <code>key</code> присутствует в коллекции, иначе <code>false</code>.</p>
                                    <p><code>map.delete(key)</code> – удаляет элемент по ключу <code>key</code>.</p>
                                    <p><code>map.clear()</code> – очищает коллекцию от всех элементов.</p>
                                    <p><code>map.size</code> – возвращает текущее количество элементов.</p>
                                    <code class="large">map.set("1", "str1").set(1, "num1").set(true, "bool1"); // цепочка вызовов</code>
                                    <h5>Перебор Map</h5>
                                    <p><code>map.keys()</code> – возвращает итерируемый объект по ключам.</p>
                                    <p><code>map.values()</code> – возвращает итерируемый объект по значениям.</p>
                                    <p><code>map.entries()</code> – возвращает итерируемый объект по парам вида <code>[ключ, значение]</code>, используется по умолчанию в <code>for..of</code>.</p>
                                    <code class="large">map.forEach((value, key, map) => {...} ) - схож с одноименным методом для массивов</code>
                                    <code class="large">for (let key of map.keys()) {
    console.log(key); // выводит все ключи map
}</code>
                                    <code class="large">for (let [key, value] of map) { ... } // получить и ключи, и значения</code>
                                    <h5>Object.fromEntries: Object из Map</h5>
                                    <p><code>Object.fromEntries(map.entries())</code>; // возвращает объект</p>
                                    <p><code>Object.fromEntries(map)</code>; // так тоже работает</p>
                                    <h4>Set</h4>
                                    <p>Объект <code>Set</code> – особый вид коллекции: «множество» уникальных значений без ключей, где каждое значение может появляться только один раз.</p>
                                    <p><code>new Set(iterable)</code> – создаёт <code>Set</code>, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый <code>Set</code>.</p>
                                    <p><code>set.add(value)</code> – добавляет значение (если оно уже есть, то ничего не делает), возвращает получившийся <code>set</code>.</p>
                                    <p><code>set.delete(value)</code> – удаляет значение, возвращает <code>true</code>, если <code>value</code> было в множестве на момент вызова, иначе <code>false</code>.</p>
                                    <p><code>set.has(value)</code> – возвращает <code>true</code>, если значение присутствует в множестве, иначе <code>false</code>.</p>
                                    <p><code>set.clear()</code> – удаляет все имеющиеся значения.</p>
                                    <p><code>set.size</code> – возвращает количество элементов в множестве.</p>
                                    <h5>Перебор Set</h5>
                                    <p><code>set.keys()</code>, <code>set.values()</code> – возвращают перебираемый объект для значений. Оба метода работают одинаково.</p>
                                    <p><code>set.entries()</code> – возвращает перебираемый объект с парами <code>[значение, значение]</code></p>
                                    <code class="large">for (let value of set) {...} // используя for..of</code>
                                    <code class="large">set.forEach((value, valueAgain, set) => { ... } ); // или forEach</code>
                                    <h4>WeakMap</h4>
                                    <p><code>WeakMap</code> и <code>WeakSet</code> используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Не являются перебираемыми.</p>
                                    <p>Ключи в <code>WeakMap</code> должны быть объектами.</p>
                                    <p>При использовании объекта в качестве ключа если больше нет ссылок на этот объект, он будет удалён из памяти (и из объекта <code>WeakMap</code>) автоматически вместе с соответствующим ему значением.</p>
                                    <p><code>weakMap.get(key)</code></p>
                                    <p><code>weakMap.set(key, value)</code></p>
                                    <p><code>weakMap.delete(key)</code></p>
                                    <p><code>weakMap.has(key)</code></p>
                                    <code class="large">let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];
let readMap = new WeakMap();
readMap.set(messages[0], new Date(2017, 1, 1));</code>
                                    <h4>WeakSet</h4>
                                    <p>В <code>WeakSet</code> можно добавлять только объекты.</p>
                                    <p>Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.</p>
                                    <p><code>weakSet.add(value)</code></p>
                                    <p><code>weakSet.has(value)</code></p>
                                    <p><code>weakSet.delete(value)</code></p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-destructuring-assignment" class="chapter__title">Деструктурирующее присваивание</h3>
                                </div>
                                <div class="chapter__content">
                                   <p>Это специальный синтаксис, который позволяет «распаковать» перебираемые объекты в несколько переменных.</p>
                                   <h4>Деструктуризация массива</h4>
                                   <code class="large">let [first, second] = [1, 2]; // first === 1, second === 2</code>
                                   <p>Ненужные элементы массива могут быть отброшены через запятую.</p>
                                   <code class="large">let [first, , third] = [1, 2, 3, 4];</code>
                                   <p>Можно использовать что угодно «присваивающее» с левой стороны.</p>
                                   <code class="large">let user = {}; // преобразуется в {name: 'John', surname: 'Smith'}
[user.name, user.surname] = "John Smith".split(' ');</code>
                                   <p>Остаточные параметры.</p>
                                   <code class="large">let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "Me"];
console.log(rest); // ['Consul', 'Me']</code>
                                   <p>Если в массиве меньше значений, чем в присваивании, они считаются неопределёнными.</p>
                                   <code class="large">let [firstName, surname] = []; // firstName === undefined</code>
                                   <p>Значения по умолчанию.</p>
                                   <code class="large">let [name = "Guest", info = prompt('')] = []; // info - результат prompt</code>
                                   <h4>Деструктуризация объекта</h4>
                                   <p>Деструктурирующее присваивание также работает с объектами.</p>
                                   <code class="large">let {height = 100, width} = { width: 200 }; // height === 100, width === 200</code>
                                   <p>Можно присвоить свойство объекта переменной с другим названием.</p>
                                   <code class="large">let { title: t } = { title: "Menu" }; // t === "Menu"</code>
                                   <p>Для получения остатка объекта можно использовать троеточие, как и для массивов.</p>
                                   <code class="large">let {one, ...rest} = { one: 1, two: 2, three: 3 };
console.log(rest); // {two: 2, three: 3}</code>
                                   <h4>Вложенная деструктуризация</h4>
                                   <code class="large">let options = { size: {width: 100, height: 200} };

let {
    size: {
        width: w,
        height,
        title = "Menu",
    },
} = options;

console.log(height); // 200
console.log(w); // 100
console.log(title); // "Menu"
console.log(size); // ReferenceError: size is not defined
console.log(width); // ReferenceError: width is not defined</code>
                                   <h4>Умные параметры функций</h4>
                                   <p>Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны.</p>
                                   <code class="large">function showMenu(title = "Untitled", width = 200, height = 100, items = []) {...}</code>
                                   <p>Можно передать параметры как объект, и функция немедленно деструктурирует его в переменные.</p>
                                   <code class="large">function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {...}
showMenu({ title: "My menu", items: ["Item1", "Item2"] });</code>
                                   <p>Если нужны значения по умолчанию, то следует передать пустой объект.</p>
                                   <code class="large">showMenu({}); // все значения - по умолчанию
showMenu(); // TypeError: Cannot read properties of undefined (reading 'title')</code>
                                   <p>Ошибку можно исправить, сделав {} значением по умолчанию для всего объекта параметров.</p>
                                   <code class="large">function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    console.log( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-date" class="chapter__title">Дата и время</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Создание объекта Date</h4>
                                    <p><code>new Date()</code> – создать с текущими датой и временем.</p>
                                    <p><code>new Date(milliseconds)</code> - таймстамп (кол-во миллисекунд, прошедших с 1 января 1970 года).</p>
                                    <p><code>new Date(datestring)</code> - строка в формате <code>YYYY-MM-DDTHH:mm:ss.sssZ</code> (обязателен только год).</p>
                                    <ul>
                                        <li><code>T</code> используется в качестве разделителя</li>
                                        <li><code>Z</code> обозначает часовой пояс в формате <code>+-hh:mm</code>. Если указать просто букву <code>Z</code>, получим UTC+0</li>
                                    </ul>
                                    <code class="large">new Date('2022-01-26T13:51:50.417-07:00'); // Wed Jan 26 2022 23:51:50 GMT+0300 (Москва, стандартное время)</code>
                                    <p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code> - аргументы (обязательны первые два).</p>
                                    <ul>
                                        <li><code>year</code> должен состоять из четырёх цифр</li>
                                        <li><code>month</code> нумеруется от <code>0</code> (январь) по <code>11</code> (декабрь)</li>
                                    </ul>
                                    <code class="large">new Date(2021, 5, 6, 8, 49); // Sun Jun 06 2021 08:49:00 GMT+0300</code>
                                    <h5>Автоисправление даты</h5>
                                    <p>Используя последний вариант можно устанавливать компоненты даты вне обычного диапазона значений (даже нулевые или отрицательные), объект сам себя исправит.</p>
                                    <code class="large">new Date(2013, 0, 32); // Fri Feb 01 2013 ...</code>
                                    <h4>Получение компонентов даты</h4>
                                    <p>Методы возвращают значения в соответствии с местным часовым поясом:</p>
                                    <p><code>getFullYear()</code> - возвращает год (4 цифры).</p>
                                    <p><code>getMonth()</code> - возвращает месяц, от <code>0</code> до <code>11</code>.</p>
                                    <p><code>getDate()</code> - возвращает день месяца, от <code>1</code> до <code>31</code>.</p>
                                    <p><code>getHours()</code>, <code>getMinutes()</code>, <code>getSeconds()</code>, <code>getMilliseconds()</code> - соответственно названиям.</p>
                                    <p><code>getDay()</code> - возвращает день недели от <code>0</code> (воскресенье) до <code>6</code> (суббота).</p>
                                    <p>Их UTC-аналоги:</p>
                                    <p><code>getUTCFullYear()</code>, <code>getUTCMonth()</code>, <code>getUTCDate()</code>, <code>getUTCHours()</code>, <code>getUTCMinutes()</code>, <code>getUTCSeconds()</code>, <code>getUTCMilliseconds()</code>, <code>getUTCDay()</code></p>
                                    <code class="large">new Date().getHours(); // 9
new Date().getUTCHours(); // 6</code>
                                    <p>2 особых методы без UTC-варианта:</p>
                                    <p><code>getTime()</code> - для заданной даты возвращает таймстамп</p>
                                    <code class="large">new Date().getTime(); // 1688275690962</code>
                                    <p><code>getTimezoneOffset()</code> - возвращает разницу в минутах между местным часовым поясом и UTC.</p>
                                    <code class="large">new Date().getTimezoneOffset(); // -180</code>
                                    <h4>Установка компонентов даты</h4>
                                    <p>Методы изменяют дату в соответствии с местным часовым поясом и возвращают таймстамп.</p>
                                    <p><code>setFullYear(year, [month], [date])</code></p>
                                    <p><code>setMonth(month, [date])</code></p>
                                    <p><code>setDate(date)</code></p>
                                    <p><code>setHours(hour, [min], [sec], [ms])</code></p>
                                    <p><code>setMinutes(min, [sec], [ms])</code></p>
                                    <p><code>setSeconds(sec, [ms])</code></p>
                                    <p><code>setMilliseconds(ms)</code></p>
                                    <code class="large">let date = new Date(2021, 5, 6, 8, 49);
date.setHours(0);
console.log( date ); // Sun Jun 06 2021 00:49:00 GMT+0300</code>
                                    <p><code>setTime(milliseconds)</code> - устанавливает дату в виде целого кол-во ms, прошедших с 01.01.1970 UTC</p>
                                    <p>Если нужно изменить дату:</p>
                                    <code class="large">let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);
console.log(date); // Tue Mar 01 2016 ...</code>
                                    <h4>Преобразование к числу, разность дат.</h4>
                                    <p>Если объект <code>Date</code> преобразовать в число, то получим таймстамп по аналогии с <code>date.getTime()</code>.</p>
                                    <code class="large">+new Date(); // 1688280813375</code>
                                    <p>Поэтому даты можно вычитать, получая разность в миллисекундах.</p>
                                    <p><code>Date.now()</code> - метод для быстрого получения текущего времени в формате таймстампа. Семантически эквивалентен <code>new Date().getTime()</code>, но не создаёт промежуточный объект <code>Date</code>. Так что этот способ работает быстрее и не нагружает сборщик мусора.</p>
                                    <h4>Разбор строки с датой</h4>
                                    <p><code>Date.parse(str)</code> считывает дату из строки.</p>
                                    <p>Формат такой же, как в случае с <code>new Date(datestring)</code>.</p>
                                    <p>Вызов <code>Date.parse(str)</code> обрабатывает строку в заданном формате и возвращает таймстамп. Если формат неправильный, возвращается <code>NaN</code>.</p>
                                    <h5>performance.now()</h5>
                                    <p>В браузерах есть метод <code>performance.now()</code>, возвращающий количество миллисекунд с начала загрузки страницы с точностью до микросекунд (корректными являются только три цифры после точки):</p>
                                    <code class="large">performance.now() // 8232.939999899827 (8.232939 секунды)</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="data-types-json" class="chapter__title">Формат JSON, метод toJSON</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Формат JSON (JavaScript Object Notation):</p>
                                    <p>Ключи объектов заключаются в двойные кавычки. Значения, если это строки, также заключаются в двойные кавычки.</p>
                                    <p>JSON поддерживает простые объекты, массивы, строки, числа, логические значения и <code>null</code>.</p>
                                    <h4>JSON.stringify</h4>
                                    <p><code>JSON.stringify(value[, replacer, space])</code> - метод для преобразования объектов в JSON.</p>
                                    <p><code>value</code> - объект для преобразования в JSON.</p>
                                    <p><code>replacer</code> - массив свойств для кодирования или функция соответствия <code>function(key, value)</code>.</p>
                                    <p><code>space</code> - указывает на кол-во пробелов для удобного форматирования.</p>
                                    <code class="large">JSON.stringify(user, null, 2);</code>
                                    <p>JSON является независимой от языка спецификацией для данных, поэтому <code>JSON.stringify</code> пропускает некоторые специфические свойства объектов JavaScript:</p>
                                    <ul>
                                        <li>cвойства-функции (методы)</li>
                                        <li>cимвольные ключи и значения</li>
                                        <li>свойства со значением <code>undefined</code></li>
                                    </ul>
                                    <p>Ограничение: не должно быть циклических ссылок.</p>
                                    <code class="large">let meetup = {
    title: "Conference",
    participants: [{name: "John"}, {name: "Alice"}],
}</code>
                                    <p>Вместо <code>replacer</code> можно передать массив свойств, которые мы хотим записать в JSON:</p>
                                    <code class="large">JSON.stringify(meetup, ['title', 'participants']); // '{"title":"Conference","participants":[{},{}]}'</code>
                                    <p>Также на месте <code>replacer</code> можно написать функцию, а не массив. Она будет вызываться для каждой пары <code>(key, value)</code> и должна возвращать замененное значение вместо исходного, либо <code>undefined</code> чтобы пропустить значение.</p>
                                    <code class="large">JSON.stringify(meetup, function replacer(key, value) {
    return (value == 'John') ? undefined : value;
}); // '{"title":"Conference","participants":[{},{"name":"Alice"}]}'</code>
                                    <p>Первый вызов – особенный. Ему передаётся специальный «объект-обёртка»: <code>{"": meetup}</code>. Другими словами, первая <code>(key, value)</code> пара имеет пустой ключ, а значением является целевой объект в общем.</p>
                                    <code class="large">JSON.stringify(meetup, function replacer(key, value) {
    if (value === meetup) console.log(key === '')
}); // true</code>
                                    <h4>Пользовательский «toJSON»</h4>
                                    <p>Если объект имеет метод toJSON для преобразования в JSON, то он вызывается через <code>JSON.stringify</code>:</p>
                                    <code class="large">let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};

let meetup = {
    title: "Conference",
    room,
};

JSON.stringify(meetup); // {"title":"Conference","room":23}</code>
                                    <h4>JSON.parse</h4>
                                    <p><code>JSON.parse(str, [reviver])</code> - метод для преобразования JSON обратно в объект.</p>
                                    <p><code>str</code> - это сам JSON для преобразования в объект.</p>
                                    <p><code>reviver</code> - необязательная ф-ция, которая будет вызываться для каждой пары <code>(ключ, значение)</code> и преобразовывать значения.</p>
                                    <p>Например, используется чтобы значения объектов <code>date</code> не оставались строками после преобразования:</p>
                                    <code class="large">let obj = {date: new Date()};
let json = JSON.stringify(obj); // "2023-07-02T09:37:28.557Z"
JSON.parse(json, function(key, value) {
    if (key === 'date') return new Date(value);
    return value;
}); // {date: Sun Jul 02 2023 12:40:39 ... }</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Продвинутая работа с функциями</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-rest-spread" class="chapter__title">Остаточные параметры и spead оператор</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Остаточные параметры (...)</h4>
                                    <p>Вызвать функцию можно с большим количеством аргументов, чем в ее объявлении. Лишние аргументы посчитаны не будут.</p>
                                    <p>Остаточные параметры соберут лишние аргументы. Они обозначаются через три точки <code>...</code> и должны располагаться в конце.</p>
                                    <code class="large">function example(first, second, ...rest) {}</code>
                                    <h4>Переменная "arguments"</h4>
                                    <p>Все аргументы функции находятся в итерируемом объекте - псевдомассиве <code>arguments</code> под своими порядковыми номерами.</p>
                                    <code class="large">function showName() {
    for (let arg of arguments) { console.log(arg); }
}

showName("Юлий", "Цезарь"); // Юлий, затем Цезарь</code>
                                    <p>У стрелочных функций переменной <code>arguments</code> нет.</p>
                                    <h4>Оператор расширения (spread)</h4>
                                    <p>Оператор расширения тоже использует <code>...</code>, но делает совершенно противоположное.</p>
                                    <p>Он «расширяет» перебираемый объект в список аргументов.</p>
                                    <code class="large">let arr = [3, 5, 1];
Math.max(...arr); // 5</code>
                                    <code class="large">let merged = [0, ...[3, 5, 1], 2, ...[8, 9, 15]];
merged; // [0, 3, 5, 1, 2, 8, 9, 15]</code>
                                    <p>Оператор расширения работает с любым перебираемым объектом.</p>
                                    <code class="large">[..."Привет"]; // ['П', 'р', 'и', 'в', 'е', 'т']</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-closure" class="chapter__title">Область видимости переменных, замыкание</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Лексическое Окружение</h4>
                                    <p>В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний объект <code>LexicalEnvironment</code>, имеющий два свойства:</p>
                                    <ol>
                                        <li><code>Environment Record</code> – объект, в котором как свойства хранятся все локальные переменные и значение <code>this</code>.</li>
                                        <li>Ссылка на внешнее лексическое окружение (то, которое соответствует коду снаружи от текущих фигурных скобок).</li>
                                    </ol>
                                    <p>Лексическое окружение, связанное со всем скриптом называется глобальным. Его ссылка на внешнее лексическое окружение имеет значение <code>null</code>.</p>
                                    <p>Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом. Работа с переменными – это на самом деле работа со свойствами этого объекта.</p>
                                    <p>Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.</p>
                                    <p>Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.</p>
                                    <h4>Вложенные функции</h4>
                                    <p>Функция называется «вложенной», когда она создаётся внутри другой функции.</p>
                                    <code class="large">function MakeCounter() {
    let count = 0;

    this.up = function() {
        return ++count;
    };

    this.down = function() {
        return --count;
    };
}

let counter = new MakeCounter();

counter.up(); // 1
counter.up(); // 2
counter.down(); // 1</code>
                                <p>Обе вложенные функции были созданы с одним и тем же внешним лексическим окружением, так что они имеют доступ к одной и той же переменной <code>count</code>.</p>
                                <h4>Окружение в деталях</h4>
                                <p>Функции «при рождении» получают скрытое свойство <code>[[Environment]]</code>, которое ссылается на лексическое окружение места, где они были созданы.</p>
                                <p>Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.</p>
                                <p>В JavaScript все функции изначально являются замыканиями, так как запоминают, где были созданы с помощью свойства <code>[[Environment]]</code> (кроме функций, созданных с помощью <code>new Function</code>, которые всегда ссылаются на глобальное лексическое окружение).</p>
                                <h4>Блоки кода и циклы</h4>
                                <p>У каждой итерации цикла своё собственное лексическое окружение.</p>
                                <p>В браузере все скрипты (кроме <code>type="module"</code>) разделяют одну общую глобальную область. Если создать глобальную переменную в одном скрипте, она станет доступна и в других, что может стать источником конфликтов при использовании одной переменной.</p>
                                <p>Если необходимо этого избежать, можно использовать блок кода <code>{...}</code> для изоляции всего скрипта или какой-то его части в «локальной области видимости».</p>
                                <h4>IIFE</h4>
                                <p>В прошлом в JavaScript не было лексического окружения на уровне блоков кода. Придумали «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления.</p>
                                <code class="large">(function() {
    var message = "Hello";
    console.log(message); // Hello
})();
console.log(message); // ReferenceError: message is not defined</code>
                                <p>Существуют разные пути создания IIFE:</p>
                                <ul>
                                    <li><code>(function() {...})();</code></li>
                                    <li><code>(function() {...}());</code></li>
                                    <li><code>!function() {...}();</code></li>
                                    <li><code>+function() {...}();</code></li>
                                    <li><code>void function() {...}();</code></li>
                                </ul>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-var-global" class="chapter__title">"var" и глобальный объект</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Устаревшее ключевое слово "var"</h4>
                                    <p>Для <code>var</code> не существует блочной области видимости. Область видимости переменных <code>var</code> ограничивается либо функцией, либо, если переменная глобальная, скриптом.</p>
                                    <p>Если блок кода находится внутри функции, то <code>var</code> становится локальной переменной в этой функции.</p>
                                    <code class="large">+function sayHi() {
    if (true) {
        var phrase = "Привет";
    }
    console.log(phrase); // "Привет"
}();
console.log(phrase); // ReferenceError: phrase is not defined</code>
                                    <p>Объявления <code>var</code> обрабатываются в начале запуска функции.</p>
                                    <code class="large">+function() {
    phrase = "Привет";
    if (false) {
        var phrase;
    }
    console.log(phrase); // Привет
}();</code>
                                    <p>Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных <code>var</code> «всплывают» в самый верх функции.</p>
                                    <p>Условие <code>if (false)</code> никогда не выполнится. Но это не препятствует созданию переменной <code>var phrase</code>, которая находится внутри него, поскольку объявления <code>var</code> «всплывают» в начало функции. В момент присвоения значения переменная уже существует.</p>
                                    <p>Отличия <code>var</code> от <code>let/const</code>:</p>
                                    <ol>
                                        <li>Переменные <code>var</code> не имеют блочной области видимости, они ограничены телом функции, либо скриптом, если переменная глобальная.</li>
                                        <li>Объявления (инициализация) переменных <code>var</code> производится в начале исполнения функции (или скрипта для глобальных переменных).</li>
                                        <li>Глобальные переменные, объявленные с помощью <code>var</code> становятся свойствами глобального объекта.</li>
                                    </ol>
                                    <h4>Глобальный объект</h4>
                                    <p>Глобальный объект хранит переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.</p>
                                    <p>В браузере он называется <code>window</code>, в Node.js — <code>global</code>, в другой среде исполнения может называться иначе.</p>
                                    <p>В язык был добавлен <code>globalThis</code> как стандартизированное имя для глобального объекта. Если скрипт может выполняться не только в браузере, лучше использовать его.</p>
                                    <p>Ко всем свойствам глобального объекта можно обращаться напрямую:</p>
                                    <code class="large">window.alert("Привет"); // то же, что и просто alert("Привет")
window.innerHeight // высота окна браузера</code>
                                    <p>В браузере глобальные функции и переменные, объявленные с помощью <code>var</code>, становятся свойствами глобального объекта. Такое поведение поддерживается для совместимости и в современных проектах, использующих JavaScript-модули, такого не происходит.</p>
                                    <code class="large">var name = 'Sergey';
console.log( window.name ); // Sergey</code>
                                    <p>Если свойство настолько важное, что нужно сделать его доступным для всей программы, то, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую:</p>
                                    <code class="large">window.currentUser = {
    name: "John"
};
console.log(currentUser.name); // John (либо window.currenUser.name)</code>
                                    <h5>Использование для полифилов</h5>
                                    <p>Глобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.</p>
                                    <code class="large">if (!window.Promise) { // проверка наличия встроенного объекта Promise
    window.Promise = ... // собственная реализация современной возможности языка
} // создаем полифил и добавляем функции, существующие в современном стандарте</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-function-object" class="chapter__title">Объект функции, NFE</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>В JavaScript функции – это объекты. Их можно передавать по ссылке, добавлять/удалять свойства и тд.</p>
                                    <p>Объект функции содержит несколько полезных свойств.</p>
                                    <h4>Свойство «name»</h4>
                                    <p>Имя функции доступно как свойство <code>name</code>.</p>
                                    <code class="large">function sayHi() {}
console.log( sayHi.name ); // "sayHi"</code>
                                    <p>Когда корректное имя определить невозможно, свойство <code>name</code> имеет пустое значение:</p>
                                    <code class="large">let arr = [function() {}];
console.log(arr[0].name === ''); // true</code>
                                    <h4>Свойство «length»</h4>
                                    <p>Встроенное свойство <code>length</code> содержит количество параметров функции в её объявлении.</p>
                                    <code class="large">function f1(a) {}
function many(a, b, ...more) {}
console.log(f1.length); // 1
console.log(many.length); // 2</code>
                                    <h4>Named Function Expression</h4>
                                    <p>Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.</p>
                                    <code class="large">let sayHi = function func() {};</code>
                                    <p>Функция всё ещё задана как Function Expression. Добавление <code>func</code> после <code>function</code> не превращает объявление в Function Declaration, потому что оно все ещё является частью выражения присваивания. Функция все еще доступна как <code>sayHi()</code>.</p>
                                    <p>Есть две особенности имени <code>func</code>, ради которого оно даётся:</p>
                                    <ol>
                                        <li>Позволяет функции ссылаться на себя же.</li>
                                        <li>Не доступно за пределами функции.</li>
                                    </ol>
                                    <code class="large">let sayHi = function func(who) {
    if (who) {
        console.log(`Hello, ${who}`);
    } else {
        func("Guest");
    }
};

sayHi(); // Hello, Guest
func(); // ReferenceError: func is not defined</code>
                                    <p>Такая функция не сломается при присвоении другой переменной. Имя NFE может быть использовано для рекурсивных вызовов и т.п.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-new-function-eval" class="chapter__title">"new Function" и eval</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Синтаксис "new Function"</h4>
                                    <p>Существует ещё один вариант объявлять функции.</p>
                                    <code class="large">let func = new Function([arg1, arg2, ...argN], functionBody);</code>
                                    <code class="large">let sum = new Function('a', 'b', 'return a + b');
sum(1, 2); // 3</code>
                                    <p><code>new Function</code> позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить её.</p>
                                    <h5>Замыкание</h5>
                                    <p>Когда функция создаётся с использованием <code>new Function</code>, в её <code>[[Environment]]</code> записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.</p>
                                    <code class="large">function getFunc() {
    let value = "test";
    let func = new Function('alert(value)');
    return func;
}

getFunc()(); // ReferenceError: value is not defined</code>
                                    <p>Без этой особенности <code>new Function</code> были бы проблемы с минификаторами, так как они дают укороченные имена переменным. Например, объявление в функции переменной <code>let userName</code> минификатор изменяет на <code>let a</code> (или другую букву, если она не занята) и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной, и никто снаружи не имеет к ней доступ.</p>
                                    <p>По историческим причинам аргументы также могут быть объявлены через запятую в одной строке. Три объявления ниже эквивалентны:</p>
                                    <ul>
                                        <li><code>new Function('a', 'b', 'return a + b'); // стандартный синтаксис</code></li>
                                        <li><code>new Function('a,b', 'return a + b'); // через запятую в одной строке</code></li>
                                        <li><code>new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке</code></li>
                                    </ul>
                                    <h4>eval</h4>
                                    <p>Встроенная функция <code>eval</code> выполняет строку кода и возвращает результат последней инструкции.</p>
                                    <code class="large">eval('let i = 0; ++i'); // 1</code>
                                    <p>Код в <code>eval</code> выполняется в текущем лексическом окружении, поэтому ему доступны внешние переменные. Значения внешних переменных можно изменять:</p>
                                    <code class="large">+function f() {
    let a = 2;
    eval('a = 10');
    console.log(a); // 10
}();</code>
                                    <p>В строгом режиме у <code>eval</code> имеется своё лексическое окружение. Поэтому функции и переменные, объявленные внутри <code>eval</code>, нельзя увидеть снаружи:</p>
                                    <code class="large">eval("let x = 5; function f() {}");
console.log(f); // ReferenceError: f is not defined</code>
                                    <p>На данный момент нет причин использовать <code>eval</code>. Код в <code>eval</code> способен получать доступ к внешним переменным, и это может иметь побочные эффекты. Минификаторы не трогают имена переменных, которые могут быть доступны из <code>eval</code>, что ухудшает степень сжатия кода.</p>
                                    <p>Существует два пути, как гарантированно избежать подобных проблем.</p>
                                    <p>Если код внутри <code>eval</code> не использует внешние переменные, можно вызвать его как <code>window.eval</code>. В этом случае код выполняется в глобальной области видимости:</p>
                                    <code class="large">let x = 1;
{
    let x = 5;
    window.eval('console.log(x)'); // 1
    new Function('console.log(x)')(); // так тоже работает
}</code>
                                    <p>Если коду внутри <code>eval</code> нужны локальные переменные, стоит заменить <code>eval</code> на <code>new Function</code> и передать необходимые данные как аргументы:</p>
                                    <code class="large">let f = new Function('a', 'console.log(a)');
f(5); // 5</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-settimeout-setinterval" class="chapter__title">Планирование: setTimeout и setInterval</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Функцию можно вызвать не в данный момент времени, а позже. Для этого существуют два метода:</p>
                                    <p><code>setTimeout</code> - позволяет вызвать функцию один раз через определённый интервал времени.</p>
                                    <p><code>setInterval</code> - позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.</p>
                                    <p>Эти методы не являются частью спецификации, но большинство сред выполнения JavaScript-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.</p>
                                    <h4>setTimeout</h4>
                                    <code class="large">let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)</code>
                                    <p><code>func|code</code> - функция для выполнения. По историческим причинам можно передать и строку кода.</p>
                                    <p><code>delay</code> - задержка перед запуском в миллисекундах. Значение по умолчанию – <code>0</code>.</p>
                                    <p><code>arg1</code>, <code>arg2</code>, … - аргументы, передаваемые в функцию.</p>
                                    <p>Данный код вызывает <code>sayHi</code> спустя одну секунду:</p>
                                    <code class="large">function sayHi(phrase, who) {
    console.log( phrase + ', ' + who );
}
setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон</code>
                                    <h5>Отмена через clearTimeout</h5>
                                    <p>Вызов <code>setTimeout</code> возвращает «идентификатор таймера» <code>timerId</code>, который можно использовать для отмены дальнейшего выполнения.</p>
                                    <code class="large">let timerId = setTimeout(...);
clearTimeout(timerId);</code>
                                    <h4>setInterval</h4>
                                    <code class="large">let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</code>
                                    <p>Функция запускается периодически через указанный интервал времени.</p>
                                    <p>Чтобы остановить дальнейшее выполнение функции, необходимо вызвать <code>clearInterval(timerId)</code>.</p>
                                    <code class="large">let timerId = setInterval(() => console.log('tick'), 2000);// повторить с интервалом 2 секунды
setTimeout(() => { clearInterval(timerId); console.log('stop'); }, 5000); // остановить вывод через 5 секунд</code>
                                    <h4>Рекурсивный setTimeout</h4>
                                    <p>Рекурсивный <code>setTimeout</code> планирует следующий вызов после окончания текущего.</p>
                                    <code class="large">let timerId = setTimeout(function tick() {
    alert('tick');
    timerId = setTimeout(tick, 2000);
}, 2000);</code>
                                    <p>В примере новый вызов <code>setTimeout</code> будет запланирован только после закрытия модального окна, вызванного <code>alert</code>, позволяя задать задержку между выполнениями более точно, чем <code>setInterval</code>.</p>
                                    <p>Ограничение браузера для <code>setInterval</code> и вложенных <code>setTimeout</code>: после пяти и более вложенных вызовов интервал должен составлять минимум 4 миллисекунды.</p>
                                    <p>Все методы планирования не гарантируют точную задержку. Таймер в браузере может замедляться по многим причинам, например, если перегружен процессор.</p>
                                    <h4>setTimeout с нулевой задержкой</h4>
                                    <p><code>setTimeout(func, 0)</code> или просто <code>setTimeout(func)</code> планирует вызов <code>func</code> настолько быстро, насколько это возможно.</p>
                                    <p>Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.</p>
                                    <code class="large">setTimeout('console.log(a)'); // 1000
let a = 0;
for (let i = 0; i &lt; 1000; i++) {
     a++;
}</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-call-apply" class="chapter__title">Декораторы и переадресация вызова, call/apply</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Прозрачное кеширование</h4>
                                    <p>Допустим, есть функция <code>slow(x)</code>, выполняющая ресурсоемкие вычисления.</p>
                                    <p>Если функция вызывается часто, мы хотим запоминать (кешировать) возвращаемые ею результаты чтобы не делать повторных вычислений.</p>
                                    <p>Вместо того, чтобы ее усложнять, заключим ее в функцию-обертку, которая добавит кеширование:</p>
                                    <code class="large">function slow(x) {
    console.log(`Called with ${x}`);
    return x;
}
  
function cachingDecorator(func) {
    let cache = new Map();

    return function(x) {
        if (cache.has(x)) {     // если кеш содержит такой x,
            return cache.get(x); // читаем из него результат
        }

        let result = func(x);    // иначе, вызываем функцию

        cache.set(x, result);    // и кешируем результат
        return result;
    };
}
  
slow = cachingDecorator(slow);
  
console.log( slow(1) ); // Called with 1, затем 1
console.log( slow(1) ); // 1</code>
                                    <p><code>cachingDecorator</code> – это декоратор, специальная функция, которая принимает другую функцию и изменяет её поведение. Можно вызвать <code>cachingDecorator</code> с любой функцией и в результате получить кеширующую обёртку. Отделяя кеширующий код от основного кода, сохраняем чистоту и простоту последнего.</p>
                                    <h4>Применение «func.call» для передачи контекста</h4>
                                    <p><code>func.call(context, arg1, arg2, ...)</code> - позволяет вызывать функцию, явно устанавливая <code>this</code>.</p>
                                    <p>Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.</p>
                                    <p>В приведённом ниже коде <code>worker.slow()</code> перестаёт работать после применения декоратора:</p>
                                    <code class="large">let worker = {
    someMethod() {
        return 1;
    },
    slow(x) {
        console.log("Called with " + x);
        return x * this.someMethod();
    }
};

console.log(worker.slow(5)); // оригинальный метод работает

worker.slow = cachingDecorator(worker.slow); 
console.log(worker.slow(5)); // TypeError: Cannot read property 'someMethod' of undefined</code>
                                    <p>Причина в том, что декоратор вызывает оригинальную функцию как <code>func(x)</code>, и она в данном случае получает <code>this = undefined</code>. Т.е. декоратор передаёт вызов оригинальному методу, но без контекста.</p>
                                    <p>Используя <code>func.call</code> исправим строку вызова оригинальной функции:</p>
                                    <code class="large">let result = func.call(this, x); // теперь this передаётся правильно</code>
                                    <p>При выполнении <code>worker.slow(5)</code> обёртка получает <code>5</code> в качестве аргумента и <code>this=worker</code> (так как это объект перед точкой).</p>
                                    <h4>Переходим к нескольким аргументам с «func.apply»</h4>
                                    <p>Синтаксис: <code>func.apply(context, args)</code></p>
                                    <p>Разница в синтаксисе между <code>call</code> и <code>apply</code> состоит в том, что <code>call</code> ожидает список аргументов, в то время как <code>apply</code> принимает псевдомассив.</p>
                                    <p>Чтобы кешировать метод с несколькими аргументами <code>worker.sum</code>, можно соединить два значения в одно. В данном случае используем строку <code>"a,b"</code> как ключ к <code>Map</code>.</p>
                                    <p>Также понадобится заменить <code>func.call(this, x)</code> на <code>func.call(this, ...arguments)</code>.</p>
                                    <code class="large">let worker = {
    sum(a, b) {
        console.log(`Called with ${a},${b}`);
        return a + b;
    }
};

function cachingDecorator(func, hash) {
    let cache = new Map();
    return function() {
        let key = hash(arguments);
        if (cache.has(key)) {
            return cache.get(key);
        }

        let result = func.call(this, ...arguments);

        cache.set(key, result);
        return result;
    };
}
  
function hash(args) {
    return args[0] + ',' + args[1];
}
  
worker.sum = cachingDecorator(worker.sum, hash);
  
console.log( worker.sum(3, 5) ); // Called with 3,5, затем 8
console.log( worker.sum(3, 5) ); // 8</code>
                                    <p>Вместо <code>func.call(this, ...arguments)</code> можно было написать <code>func.apply(this, arguments)</code>.</p>
                                    <h4>Заимствование метода</h4>
                                    <code class="large">function hash() {
    return arguments.join(); // TypeError: arguments.join is not a function
}

function hash() {
    return [].join.call(arguments); // работает
}</code>
                                    <p>Мы берём (заимствуем) метод <code>join</code> из обычного массива <code>[].join</code>. И используем <code>[].join.call</code>, чтобы выполнить его в контексте <code>arguments</code>. Алгоритм встроенного метода <code>arr.join(glue)</code> допускает любой псевдомассив <code>this</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-bind" class="chapter__title">Привязка контекста к функции</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Синтаксис:</p>
                                    <code class="large">let boundFunc = func.bind(context, [arg1], [arg2], ...);
let user = { name: "Вася" };
function f() {
    console.log(this.name);
}

let func = f.bind(user);
func(); // Вася</code>
                                    <p>Если у объекта много методов и мы планируем их активно передавать, можно привязать контекст для них всех в цикле:</p>
                                    <code class="large">for (let key in user) {
    if (typeof user[key] == 'function') {
        user[key] = user[key].bind(user);
    }
}</code>
                                    <p>Некоторые JS-библиотеки предоставляют встроенные функции для удобной массовой привязки контекста, например <code>_.bindAll(obj)</code> в lodash.</p>
                                    <h4>Частичное применение</h4>
                                    <p>Частичное применение - это создание новой функции с фиксированием одного или нескольких из существующих параметров.</p>
                                    <code class="large">let mul = (a, b) => a * b;
let double = mul.bind(null, 2); // фиксируем контекст и первый аргумент
console.log(double(3)); // 6</code>
                                    <h4>Частичное применение без контекста</h4>
                                    <p>Экзотический объект <code>bound function</code>, возвращаемый при первом вызове <code>f.bind(...)</code>, запоминает контекст (и аргументы, если они были переданы) только во время создания.</p>
                                    <p>Поскольку <code>bind</code> не позволяет зафиксировать аргументы без контекста, можно создать вспомогательную функцию, которая будет привязывать только аргументы.</p>
                                    <code class="large">function partial(func, ...boundArgs) {
    return function(...args) {
        return func.call(this, ...boundArgs, ...args);
    }
}

let user = {
    firstName: "John",
    say(time, phrase) {
        console.log(`[${time}] ${this.firstName}: ${phrase}!`);
    }
};

user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes()); // частично применённый метод с фиксированным временем
user.sayNow("Hello"); // [10:00] John: Hello!</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-currying" class="chapter__title">Каррирование</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как <code>f(a, b, c)</code>, а как <code>f(a)(b)(c)</code>.</p>
                                    <p>Для каррирования необходима функция с фиксированным количеством аргументов. Функцию, которая использует остаточные параметры, типа <code>f(...args)</code>, каррировать не получится.</p>
                                    <p>Создадим вспомогательную функцию <code>curry(f)</code>, которая выполняет каррирование функции <code>f</code> с двумя аргументами. Другими словами, <code>curry(f)</code> для функции <code>f(a, b)</code> трансформирует её в <code>f(a)(b)</code>.</p>
                                    <code class="large">function curry(f) {
    return function(b) {
            return function(a) {
            return f(a, b);
        };
    };
}
  
function sum(a, b) {
    return a + b;
}
  
let carriedSum = curry(sum);
console.log( carriedSum(1)(2) ); // 3</code>
                                    <h4>Продвинутая реализация каррирования</h4>
                                    <p>Реализация каррирования для функций с множеством аргументов:</p>
                                    <code class="large">function curry(func) {
    return function wrapper(...args) {
        if (args.length &lt; func.length) {
            return function(...args2) {
                return wrapper.call(this, ...args, ...args2);
            }
        }

        return func.apply(this, args);
    }
}</code>
                                    <p>Применение:</p>
                                    <code class="large">function sum(a, b, c) {
    return a + b + c;
}
  
let curriedSum = curry(sum);
  
console.log( curriedSum(1, 2, 3) ); // можно вызывать нормально
console.log( curriedSum(1)(2,3) ); // каррирование первого аргумента
console.log( curriedSum(1)(2)(3) ); // каррирование всех аргументов</code>
                                    <h4>Каррирование на практике</h4>
                                    <p>С помощью каррирования можно создавать частично применённые функции, не теряя возможности пользоваться функцией как обычно.</p>
                                    <code class="large">function log(date, importance, message) {
    let formatDate = (date.getHours() + ':' + date.getMinutes()).replace(/\b\d\b/g, '0$&');
    console.log(`${formatDate} ${importance} ${message}`);
}
  
log = curry(log);
let logNow = log(new Date());
logNow("DEBUG", "some debug"); // 18:05 DEBUG some debug</code>
                                    <p>Можно пойти дальше и сделать удобную функцию для отладочных логов с текущим временем:</p>
                                    <code class="large">let debugNow = logNow("DEBUG");</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="advanced-functions-arrow-functions" class="chapter__title">Стрелочные функции</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>У стрелочных функций нет <code>this</code>.</p>
                                    <p>Отсутствие <code>this</code> ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы и вызваны с <code>new</code>.</p>
                                    <code class="large">let User = () => {
    return { name: "John" }; // даже если не использовать this
}

let user = new User(); // TypeError: User is not a constructor</code>
                                    <p>Стрелочные функции не имеют переменной <code>arguments</code>.</p>
                                    <p>У них также нет <code>super</code>.</p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Регулярные выражения</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-introduction" class="chapter__title">Шаблоны, флаги, якоря</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Синтаксис создания регулярного выражения:</p>
                                    <ol>
                                        <li><code>let regexp = new RegExp("шаблон", "флаги");</code></li>
                                        <li><code>let regexp = /шаблон/флаги;</code></li>
                                    </ol>
                                    <p>Основная разница между этими двумя способами создания в том, что слеши <code>/.../</code> не допускают вставок переменных (наподобие возможных в строках через <code>${...}</code>).</p>
                                    <h4>Якоря</h4>
                                    <p>Символы <code>^</code> (начало строки) и <code>$</code> (конец строки) - аналоги методов <code>startsWith</code> и <code>endsWith</code>.</p>
                                    <p>Оба якоря вместе <code>^...$</code> используются для проверки на полное совпадение.</p>
                                    <code class="large">let regexp = /^\d\d:\d\d$/;</code>
                                    <h5>Граница слова: \b</h5>   
                                    <p>Границей слова считается:</p>
                                    <ol>
                                        <li>Начало текста, если его первый символ <code>\w</code>.</li>
                                        <li>Позиция внутри текста, если слева находится <code>\w</code>, а справа – не <code>\w</code>, или наоборот.</li>
                                        <li>Конец текста, если его последний символ <code>\w</code>.</li>
                                    </ol>
                                    <code class="large">"13:4:1".replace(/\b\d\b/g, "0$&") // 13:04:01</code>
                                    <h4>Флаги</h4>
                                    <p><code>i</code> - поиск не зависит от регистра символов.</p>
                                    <p><code>g</code> - «global», ищет все совпадения.</p>
                                    <p><code>m</code> - многострочный режим. Влияет только на поведение якорей <code>^</code> и <code>$</code> - они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.</p>
                                    <p><code>s</code> - «dotall», точка <code>.</code> может соответствовать символу перевода строки <code>\n</code>.</p>
                                    <p><code>u</code> - поддержка Юникода, корректная обработка суррогатных пар.</p>
                                    <p><code>y</code> - режим поиска на конкретной позиции в тексте.</p>
                                    <h4>Методы</h4>
                                    <h5>Поиск: str.match(regexp)</h5>
                                    <ol>
                                        <li>С флагом <code>g</code> возвращает массив всех совпадений.</li>
                                        <li>Без <code>g</code> возвращает первое совпадение в виде массива.</li>
                                        <li>Если совпадений нет, возвращается <code>null</code>.</li>
                                    </ol>
                                    <h5>Поиск: str.search(regexp)</h5>
                                    <p><code>str.search(regexp)</code> возвращает позицию первого совпадения с <code>regexp</code> в строке <code>str</code> или <code>-1</code>, если совпадения нет.</p>
                                    <h5>Проверка: regexp.test(str)</h5>
                                    <p><code>regexp.test(str)</code> возвращает <code>true</code>, есть ли есть хоть одно совпадение, иначе <code>false</code>.</p>
                                    <h5>Замена: str.replace(regexp, replacement)</h5>
                                    <p>Совпадения с <code>regexp</code> заменяются на <code>replacement</code>. В строке замены <code>replacement</code> можно использовать спецсимволы для вставки фрагментов совпадения:</p>
                                    <ul>
                                        <li><code>$&</code> - вставляет всё найденное совпадение</li>
                                        <li><code>$`</code> - вставляет часть строки до совпадения</li>
                                        <li><code>$'</code> - вставляет часть строки после совпадения</li>
                                        <li><code>$n</code> - если <code>n</code> это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения</li>
                                        <li><code>$&lt;name></code> - вставляет содержимое скобочной группы с именем <code>name</code></li>
                                        <li><code>$$</code> - вставляет символ <code>$</code></li>
                                    </ul>
                                    <p><code>str.replace(str|regexp, str|func)</code> - полный синтаксис.</p>
                                    <p>Когда первый аргумент <code>replace</code> является строкой, он заменяет только первое совпадение.</p>
                                    <p>Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция, которая будет вызываться для каждого совпадения с аргументами <code>func(match, p1, p2, ..., pn, offset, input, groups)</code>:</p>
                                    <ul>
                                        <li><code>match</code> – найденное совпадение</li>
                                        <li><code>p1</code>, <code>p2</code>, ..., <code>pn</code> – содержимое скобочных групп</li>
                                        <li><code>offset</code> – позиция, на которой найдено совпадение</li>
                                        <li><code>input</code> – исходная строка</li>
                                        <li><code>groups</code> – объект с содержимым именованных скобок</li>
                                    </ul>
                                    <code class="large">"html and css".replace(/html|css/gi, str => str.toUpperCase()); // HTML and CSS</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-classes" class="chapter__title">Символьные классы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Наиболее используемые:</p>
                                    <ul>
                                        <li><code>\d</code> - «digit», символ от <code>0</code> до <code>9</code></li>
                                        <li><code>\s</code> - «space», пробел, <code>\t</code>, <code>\n</code> и другие (<code>\v</code>, <code>\f</code> и <code>\r</code>)</li>
                                        <li><code>\w</code> - «word», <code>a-zA-Z0-9_</code> (символ латинского алфавита, цифра или подчёркивание)</li>
                                    </ul>
                                    <p>Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре:</p>
                                    <ul>
                                        <li>\<code>D</code> - не цифра</li>
                                        <li><code>\S</code> - не пробельный символ</li>
                                        <li><code>\W</code> - любой символ, кроме <code>\w</code> (например, символы русского алфавита)</li>
                                    </ul>
                                    <p>Точка <code>.</code> – это специальный символьный класс, который соответствует «любому символу, кроме новой строки», но если регулярное выражение имеет флаг <code>s</code>, то точка <code>.</code> соответствует буквально любому символу.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-unicode" class="chapter__title">Юникод: флаг "u" и класс \p{...}</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Флаг <code>u</code> включает поддержку Юникода в регулярных выражениях, то есть:</p>
                                    <ol>
                                        <li>Символы из 4 байт воспринимаются как единое целое, а не как два символа по 2 байта</li>
                                        <li>Работает поиск по Юникодным свойствам <code>\p{…}</code></li>
                                    </ol>
                                    <h5>Юникодные свойства \p{…}</h5>
                                    <p>Каждому символу в кодировке Юникод соответствует множество свойств. В регулярном выражении можно искать символ с заданным свойством, указав его в <code>\p{…}</code>.</p>
                                    <p>Некоторые категории символов:</p>
                                    <ul>
                                        <li><code>L</code> - буквы</li>
                                        <li><code>N</code> - числа
                                            <ul>
                                                <li><code>Hex_Digit</code> - шестнадцатеричная цифра</li>
                                            </ul>
                                        </li>
                                        <li><code>P</code> - знаки пунктуации</li>
                                        <li><code>S</code> - символы
                                            <ul>
                                                <li><code>Currency_Symbol</code> - знаки валюты</li>
                                            </ul>
                                        </li>
                                    </ul>
                                    <p>Свойство <code>Script</code> (или, сокращенно, <code>sc</code>) - система написания. Может иметь значения <code>Cyrillic</code>, <code>Greek</code>, <code>Arabic</code> <a target="_blank" href="https://en.wikipedia.org/wiki/Script_(Unicode)">и другие</a>.</p>
                                    <code class="large">\p{sc=Han} - поиск китайских иероглифов
\P{sc=Cyrillic} - поиск символов, отличных от кириллических</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-escaping" class="chapter__title">Экранирование, специальные символы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Специальные символы, которые имеют особое значение в регулярном выражении: <code>[</code> <code>]</code> <code>\</code> <code>^</code> <code>$</code> <code>.</code> <code>|</code> <code>?</code> <code>*</code> <code>+</code> <code>(</code> <code>)</code></p>
                                    <h4>Экранирование символов</h4>
                                    <p>Чтобы использовать специальный символ как обычный, необходимо добавить перед ним обратную косую черту <code>\</code>.</p>
                                    <p>Символ косой черты <code>/</code>, так называемый «слэш», не является специальным символом, но он используется для открытия и закрытия регулярного выражения, поэтому его тоже нужно экранировать.</p>
                                    <h4>new RegExp</h4>
                                    <p>Строковые кавычки «съедают» символы обратной косой черты.</p>
                                    <code class="large">new RegExp("\d\.\d"); // d.d</code>
                                    <p>Чтобы исправить это, необходимо удвоить обратную косую черту.</p>
                                    <code class="large">new RegExp("\\d\\.\\d"); // \d\.\d (теперь правильно)</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-sets-and-ranges" class="chapter__title">Наборы и диапазоны [...]</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>[eao]</code> - набор, ищет любой символ из заданных.</p>
                                    <p><code>[a-z]</code> - соответствует диапазону символов от <code>a</code> до <code>z</code>.</p>
                                    <p><code>[^aeyo]</code> - соответствуют любому символу за исключением заданных.</p>
                                    <p>Символьные классы - сокращение для наборов символов:</p>
                                    <ul>
                                        <li><code>\d</code> – то же самое, что и <code>[0-9]</code></li>
                                        <li><code>\w</code> – то же самое, что и <code>[a-zA-Z0-9_]</code></li>
                                        <li><code>\D</code> - то же самое, что и <code>[^0-9]</code></li>
                                    </ul>
                                    <p>Внутри <code>[...]</code> экранировать необходимо только закрывающую квадратную скобку <code>]</code>, тире <code>-</code> не надо экранировать в начале или в конце (где оно не задаёт диапазон), символ каретки <code>^</code> нужно экранировать только в начале (где он означает исключение).</p>
                                    <p>Если в наборе есть суррогатные пары, для корректной работы обязательно нужен флаг <code>u</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-quantifiers" class="chapter__title">Квантификаторы +, *, ? и {n}</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Квантификаторы указывают количество повторений символа.</p>
                                    <p>Самый простой квантификатор — это число в фигурных скобках: <code>{n}</code>.</p>
                                    <code class="large">{5} - точное количество
{3,5} - диапазон, от 3 до 5
{3,} - диапазон, 3 и более (верхнюю границу можно не указывать)</code>
                                    <p>Для самых востребованных квантификаторов есть сокращённые формы записи:</p>
                                    <ul>
                                        <li><code>+</code> эквивалентен <code>{1,}</code>, то есть один или более</li>
                                        <li><code>?</code> эквивалентен <code>{0,1}</code>, то есть ноль или один</li>
                                        <li><code>*</code> эквивалентен <code>{0,}</code>, то есть ноль или более</li>
                                    </ul>
                                    <code class="large">/&lt;\/?[a-z][a-z0-9]*>/i // регулярное выражение для «открывающего или закрывающего HTML-тега без атрибутов»</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-greedy-and-lazy" class="chapter__title">Жадные и ленивые квантификаторы</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Жадный поиск</h4>
                                    <p>В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.</p>
                                    <code class="large">'a "witch" and her "broom" is one'.match(/".+"/g) // "witch" and her "broom"</code>
                                    <p>Движок регулярного выражения пытается получить максимальное количество символов, соответствующих <code>.+</code>, а затем сокращает это количество символ за символом, если остаток шаблона не совпадает.</p>
                                    <h4>Ленивый режим</h4>
                                    <p>«Ленивый» режим противоположен «жадному». Он означает: «повторять квантификатор наименьшее количество раз».</p>
                                    <p>Мы можем включить его, вставив знак вопроса <code>?</code> после квантификатора, то есть будет <code>*?</code> или <code>+?</code> или даже <code>??</code> для <code>?</code>.</p>
                                    <code class="large">'a "witch" and her "broom" is one'.match(/".+?"/g) // "witch", "broom"</code>
                                    <code class="large">let regexp = /"[^"]+"/g; // альтернативный подход с тем же результатом</code>
                                    <p>Иногда хорошо настроенный жадный поиск лучше использования ленивого режима.</p>
                                    <p>Например, если нужно найти ссылки вида <code>&lt;a href="..." class="doc"></code>, с произвольным <code>href</code>:</p>
                                    <code class="large">let str = '...&lt;a href="link1" class="wrong">... &lt;p style="" class="doc">...';
let regexp = /&lt;a href=".*?" class="doc">/g; // &lt;a href="link1" class="wrong">... &lt;p style="" class="doc">
let regexp = /&lt;a href="[^"]*" class="doc">/g; // null (верный результат)</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-groups" class="chapter__title">Скобочные группы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Часть шаблона можно заключить в скобки <code>(...)</code>, или «скобочную группу»:</p>
                                    <ol>
                                        <li>Это позволяет поместить часть совпадения в отдельное свойство.</li>
                                        <li>Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.</li>
                                    </ol>
                                    <p>Например, регулярное выражение для поиска доменов (mail.com, my-site.users.mail.com):</p>
                                    <code class="large">let regexp = /([\w-]+\.)+\w+/g;</code>
                                    <p>Пример можно расширить, создав регулярное выражение для поиска email (формат: <code>имя@домен</code>):</p>
                                    <code class="large">let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;</code>
                                    <h4>Содержимое скобок в match</h4>
                                    <p>Метод <code>str.match(regexp)</code> (для <code>regexp</code> без флага <code>g</code>) ищет первое совпадение и возвращает его в виде массива: на позиции <code>0</code> будет всё совпадение целиком, на позиции <code>1</code> – содержимое первой скобочной группы, на позиции <code>2</code> –  второй и тд.</p>
                                    <p>Скобки могут быть и вложенными (их номера идут слева направо, по открывающей скобке).</p>
                                    <p>Если скобочная группа необязательна (стоит квантификатор <code>(...)?</code>), соответствующий элемент массива существует и равен <code>undefined</code>.</p>
                                    <code class="large">let match = 'a'.match(/a(z)?/);
match[0] // a (всё совпадение)
match[1] // undefined</code>
                                    <h4>Поиск всех совпадений с группами: matchAll</h4>
                                    <p>При поиске с флагом <code>g</code> метод <code>match</code> не вернет скобочные группы. Необходимо использовать <code>matchAll</code> (может потребоваться полифил):</p>
                                    <ol>
                                        <li>Он возвращает не массив, а перебираемый объект.</li>
                                        <li>При поиске с флагом <code>g</code>, он возвращает каждое совпадение в виде массива со скобочными группами.</li>
                                        <li>Если совпадений нет, он возвращает не <code>null</code>, а просто пустой перебираемый объект.</li>
                                    </ol>
                                    <code class="large">let results = '&lt;h1> &lt;h2>'.matchAll(/&lt;(.*?)>/gi);</code>
                                    <p>Для оптимизации при вызове <code>matchAll</code> движок JavaScript возвращает перебираемый объект, в котором ещё нет результатов:</p>
                                    <code class="large">alert(results); // [object RegExp String Iterator]</code>
                                    <p>Получить результаты можно так:</p>
                                    <ol>
                                        <li><code>results = Array.from(results);</code> // превращаем в массив</li>
                                        <li><code>for(let result of results);</code> // перебираем в цикле</li>
                                        <li><code>let [tag1, tag2] = results;</code> // или используем деструктуризацию</li>
                                    </ol>
                                    <h4>Именованные группы</h4>
                                    <p>Для удобства скобкам можно присваивать имена добавлением <code>?&lt;name></code> после открытия скобки.</p>
                                    <p>Именованные группы располагаются в свойстве <code>groups</code> результата <code>match</code>.</p>
                                    <code class="large">let dateRegexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/;
"2019-04-30".match(dateRegexp).groups; // {year: '2019', month: '04', day: '30'}</code>
                                    <h4>Скобочные группы при замене</h4>
                                    <p>Метод <code>str.replace(regexp, replacement)</code> позволяет использовать в строке замены содержимое скобок при помощи обозначений вида <code>$n</code>, где <code>n</code> – номер скобочной группы.</p>
                                    <p>Для именованных скобок можно также использовать ссылку как <code>$&lt;имя></code>.</p>
                                    <code class="large">let regexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/g;
"2019-10-30".replace(regexp, '$3.$&lt;month>.$&lt;year>'); // 30.10.2019</code>
                                    <h4>Исключение из запоминания через :?</h4>
                                    <p>Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало <code>?:</code>.</p>
                                    <code class="large">let regexp = /(?:go)+ (\w+)/i;
"Gogogo John!".match(regexp).length; // 2 (Gogogo John, John)</code>
                                    <p>Также мы не можем ссылаться на такие скобки в строке замены.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-backreferences" class="chapter__title">Обратные ссылки в шаблоне: \N и \k&lt;имя></h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Необходимо найти строки в кавычках: либо одинарных <code>'...'</code>, либо двойных <code>"..."</code> – оба варианта должны подходить.</p>
                                    <code class="large">let str = `He said: "She's the one!".`;</code>
                                    <p>По номеру:</p>
                                    <code class="large">let regexp = /(['"])(.*?)\1/g;
str.match(regexp); // "She's the one!"</code>
                                    <p>Движок регулярных выражений находит первую кавычку из шаблона <code>(['"])</code> и запоминает её содержимое. Далее в шаблоне <code>\1</code> означает «найти то же самое, что в первой скобочной группе».</p>
                                    <p>То же самое по имени:</p>
                                    <code class="large">let regexp = /(?&lt;quote>['"])(.*?)\k&lt;quote>/g;</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-alternation" class="chapter__title">Альтернация (или) |</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Альтернация, в отличии от квадратных скобок, применяется ко всему шаблону.</p>
                                    <p>Чтобы применить альтернацию только к части шаблона, нужно заключить её в скобочную группу.</p>
                                    <p>Пример - поиск времени в правильном формате:</p>
                                    <code class="large">let regexp = /([01]\d|2[0-3]):[0-5]\d/g;
"10:10 23:59 25:99 1:2".match(regexp); // 10:10,23:59</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-lookahead-lookbehind" class="chapter__title">Опережающие и ретроспективные проверки</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Синтаксис опережающей проверки: <code>X(?=Y)</code></p>
                                    <p>Он означает: найди <code>X</code> при условии, что за ним следует <code>Y</code>, где <code>X</code> и <code>Y</code> - любой шаблон.</p>
                                    <code class="large">let regexp = /\d+(?=€)/;
"1 индейка стоит 30€".match(regexp); // 30</code>
                                    <p>Возможны и более сложные проверки, например <code>X(?=Y)(?=Z)</code> (искать <code>X</code> при условии, что за ним идёт и <code>Y</code> и <code>Z</code>).</p>
                                    <p>Синтаксис негативной опережающей проверки: <code>X(?!Y)</code></p>
                                    <p>Он означает: найди такой <code>X</code>, за которым НЕ следует <code>Y</code>.</p>
                                    <h4>Ретроспективная проверка</h4>
                                    <p>Низкая (&lt;90%) браузерная совместимость!</p>
                                    <p>Синтаксис ретроспективной проверки: <code>(?&lt;=Y)X</code></p>
                                    <p>Синтаксис негативной ретроспективной проверки: <code>(?&lt;!Y)X</code></p>
                                    <code class="large">let regexp = /(?&lt;=\$)\d+/g;
"1 индейка стоит $30".match(regexp); // 30</code>
                                    <h4>Скобочные группы</h4>
                                    <p>Чтобы включить содержимое скобок в результат совпадения при таких проверках, необходимо добавить еще одни скобки:</p>
                                    <code class="large">let regexp = /\d+(?=(€))/</code>
                                    <h4>Запрет катастрофического возврата</h4>
                                    <p>В некоторых случаях регулярные выражения могут выполняться очень долго:</p>
                                    <code class="large">let regexp = /^(\d+)*$/;
regexp.test("012345678901234567890123456789!") // скрипт зависнет на какое-то время</code>
                                    <p>Движок не доходит до конца и начинает "отступать", по-разному разбивая строку. Кол-во комбинаций в данном случае - <code>2^n - 1</code>.</p>
                                    <p>Исправить можно уменьшив кол-во комбинаций или запретив возврат.</p>
                                    <p>Шаблон, захватывающий максимальное количество повторений <code>\w</code> без возврата, выглядит так: <code>(?=(\w+))\1</code>.</p>
                                    <code class="large">"JavaScript".match(/\w+Script/); // JavaScript (происходит возврат)
"JavaScript".match(/(?=(\w+))\1Script/); // null (шаблон \1 забрал на себя все буквы)</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="regexp-sticky" class="chapter__title">Поиск на заданной позиции, флаг "y"</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Для поиска, начиная с нужной позиции, можно использовать метод <code>regexp.exec(str)</code>.</p>
                                    <p>Без флагов <code>g</code> и <code>y</code> этот ищет первое совпадение в строке аналогично <code>str.match(regexp)</code>.</p>
                                    <p>С флагом <code>g</code> осуществляет поиск начиная с позиции, заданной свойством <code>regexp.lastIndex</code>.</p>
                                    <p>Последовательные вызовы <code>regexp.exec</code> могут найти все совпадения (альтернатива методу <code>str.matchAll</code>).</p>
                                    <p>Можно самостоятельно задать <code>lastIndex</code>, начав поиск с нужной позиции.</p>
                                    <p>Флаг <code>y</code> заставляет <code>regexp.exec</code> искать ровно на позиции <code>lastIndex</code>. Использование флага <code>y</code> – ключ к хорошей производительности.</p>
                                    <code class="large">let str = 'let varName = "value"';
let regexp = /\w+/y;
regexp.lastIndex = 3;
regexp.exec(str); // null (на позиции 3 пробел, а не слово)
regexp.lastIndex = 4;
regexp.exec(str); // varName (слово на позиции 4)</code>
                                    <p><code>regexp.test</code> с флагом <code>g</code> ищет, начиная с <code>regexp.lastIndex</code> и обновляет это свойство как и <code>regexp.exec</code>.</p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Свойства объекта, их конфигурация</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="property-descriptors" class="chapter__title">Флаги и дескрипторы свойств</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Флаги свойств</h4>
                                    <p>Помимо значения <code>value</code>, свойства объекта имеют три специальных атрибута (так называемые «флаги»). Когда мы создаём свойство «обычным способом», все они имеют значение <code>true</code>.</p>
                                    <p><code>writable</code> – если <code>truthy</code>, свойство можно изменить, иначе оно только для чтения.</p>
                                    <p><code>enumerable</code> – если <code>truthy</code>, свойство перечисляется в циклах, в противном случае циклы его игнорируют.</p>
                                    <p><code>configurable</code> – если <code>truthy</code>, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.</p>
                                    <p>Метод <code>Object.getOwnPropertyDescriptor</code> позволяет получить полную информацию о свойстве.</p>
                                    <code class="large">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</code>
                                    <p><code>obj</code> - объект, из которого мы получаем информацию.</p>
                                    <p><code>propertyName</code> - имя свойства.</p>
                                    <code class="large">let user = { name: "John" };

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log(descriptor); // {value: "John", writable: true, enumerable: true, configurable: true}</code>
                                    <p>Чтобы изменять флаги, существует метод <code>Object.defineProperty</code>.</p>
                                    <code class="large">Object.defineProperty(obj, propertyName, descriptor);</code>
                                    <p><code>obj</code>, <code>propertyName</code> - объект и его свойство, для которого нужно применить дескриптор.</p>
                                    <p><code>descriptor</code> - применяемый дескриптор.</p>
                                    <p>Если свойство существует, <code>defineProperty</code> обновит его флаги. Иначе метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение <code>false</code>.</p>
                                    <code class="large">let user = {};
Object.defineProperty(user, "name", { value: "John" });

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log(descriptor); // {value: 'John', writable: false, enumerable: false, configurable: false}</code>
                                    <h4>Только для чтения</h4>
                                    <p>Сделаем свойство <code>user.name</code> доступным только для чтения. Для этого изменим флаг <code>writable</code>:</p>
                                    <code class="large">let user = { name: "John" };
Object.defineProperty(user, "name", { writable: false });

user.name = "Pete"; // TypeError: Cannot assign to read only property 'name' of object '#&lt;Object>'</code>
                                    <p>Ошибка появляется только в строгом режиме. Но без <code>'use strict'</code> операция записи в свойство «только для чтения» всё равно не будет выполнена успешно.</p>
                                    <h4>Неперечислимое свойство</h4>
                                    <p>Встроенный метод <code>toString</code> в объектах – неперечислимый, его не видно в цикле <code>for..in</code>.</p>
                                    <p>Мы можем написать свой <code>toString</code>, который будет неперечислимым.</p>
                                    <code class="large">let user = {
    name: "John",
    toString() {
        return this.name;
    }
};

Object.defineProperty(user, "toString", {
    enumerable: false
});

for (let key in user) console.log(key); // name</code>
                                    <p>Неперечислимые свойства также не возвращаются <code>Object.keys</code>:</p>
                                    <code class="large">console.log(Object.keys(user)); // name</code>
                                    <h4>Неконфигурируемое свойство</h4>
                                    <p>Флаг неконфигурируемого свойства (<code>configurable:false</code>) иногда предустановлен для некоторых встроенных объектов и свойств.</p>
                                    <p>Неконфигурируемое свойство не может быть удалено.</p>
                                    <p>Например, свойство <code>Math.PI</code> – только для чтения, неперечислимое и неконфигурируемое.</p>
                                    <code class="large">let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');
console.log(descriptor); // {value: 3.141592653589793, writable: false, enumerable: false, configurable: false}</code>
                                    <p>Определение свойства как неконфигурируемого невозможно отменить, потому что <code>defineProperty</code> не работает с неконфигурируемыми свойствами.</p>
                                    <code class="large">Object.defineProperty(Math, 'PI', {writable: true}); // TypeError: Cannot redefine property: PI</code>
                                    <p>Ошибки отображаются только в строгом режиме. Операции всё равно не будут выполнены успешно.</p>
                                    <h4>Object.defineProperties и .getOwnPropertyDescriptors</h4>
                                    <p>Метод <code>Object.defineProperties</code> позволяет определять множество свойств сразу.</p>
                                    <code class="large">Object.defineProperties(obj, { prop1: descriptor1, prop2: descriptor2, ... });

Object.defineProperties(user, {
    name: { value: "John", writable: false },
    surname: { value: "Smith", writable: false },
});</code>
                                    <p>Метод <code>Object.getOwnPropertyDescriptors</code> возвращает все дескрипторы всех свойств, включая свойства-символы.</p>
                                    <p>Вместе с <code>Object.defineProperties</code> этот метод можно использовать для неглубокого клонирования объекта вместе с его флагами:</p>
                                    <code class="large">let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));</code>
                                    <h4>Глобальное запечатывание объекта</h4>
                                    <p>Методы, которые ограничивают доступ ко всему объекту:</p>
                                    <p><code>Object.preventExtensions(obj)</code> - запрещает добавлять новые свойства в объект.</p>
                                    <p><code>Object.seal(obj)</code> - запрещает добавлять/удалять свойства. Устанавливает <code>configurable: false</code> для всех существующих свойств.</p>
                                    <p><code>Object.freeze(obj)</code> - Запрещает добавлять/удалять/изменять свойства. Устанавливает <code>configurable: false</code>, <code>writable: false</code> для всех существующих свойств.</p>
                                    <p>А также есть методы для их проверки:</p>
                                    <p><code>Object.isExtensible(obj)</code> - возвращает <code>false</code>, если добавление свойств запрещено, иначе <code>true</code>.</p>
                                    <p><code>Object.isSealed(obj)</code> - возвращает <code>true</code>, если добавление/удаление свойств запрещено и для всех существующих свойств установлено <code>configurable: false</code>.</p>
                                    <p><code>Object.isFrozen(obj)</code> - Возвращает <code>true</code>, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено <code>configurable: false</code>, <code>writable: false</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="property-accessors" class="chapter__title">Свойства - геттеры и сеттеры</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Свойства объекта делятся на cвойства-данные (<code>data properties</code>) и свойства-аксессоры (<code>accessor properties</code>).</p>
                                    <p>Первые рассмотрены в предыдущей главе. Вторые - это функции, которые используются для присвоения и получения значения, но во внешнем коде выглядят как обычные свойства объекта.</p>
                                    <h4>Геттеры и сеттеры</h4>
                                    <p>Свойства-аксессоры представлены методами: <code>get</code> (геттер) – для чтения и <code>set</code> (сеттер) – для записи.</p>
                                    <p>Добавим в объект со свойствами <code>name</code> и <code>surname</code> свойство <code>fullName</code> для полного имени. Чтобы не дублировать уже имеющуюся информацию, реализуем его при помощи аксессора.</p>
                                    <code class="large">let user = {
    name: "John",
    surname: "Smith",

    get fullName() {
        return `${this.name} ${this.surname}`;
    }
};

console.log(user.fullName); // John Smith
user.fullName = "Тест"; // TypeError: Cannot set property fullName of #&lt;Object> which has only a getter</code>
                                    <p>Исправим ошибку, добавив сеттер для <code>user.fullName</code>:</p>
                                    <code class="large">let user = {
    name: "John",
    surname: "Smith",

    get fullName() {
        return `${this.name} ${this.surname}`;
    },

    set fullName(value) {
        [this.name, this.surname] = value.split(" ");
    }
};

user.fullName = "Alice Cooper";

console.log(user.name); // Alice
console.log(user.surname); // Cooper</code>
                                    <p>В итоге получено «виртуальное» свойство <code>fullName</code>. Его можно прочитать и изменить.</p>
                                    <h4>Дескрипторы свойств доступа</h4>
                                    <p>Свойство объекта может быть либо свойством-аксессором, либо свойством-данным.</p>
                                    <p>Свойства-аксессоры не имеют <code>value</code> и <code>writable</code>, но взамен предлагают функции <code>get</code> и <code>set</code>. То есть, дескриптор аксессора имеет атрибуты <code>get</code>, <code>set</code>, <code>enumerable</code>, <code>configurable</code>.</p>
                                    <code class="large">let user = {
    name: "John",
    surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
    get() { return `${this.name} ${this.surname}` },
    set(value) { [this.name, this.surname] = value.split(" ") },
});

console.log(user.fullName); // John Smith
for (let key in user) console.log(key); // name, затем surname</code>
                                    <h4>Умные геттеры/сеттеры</h4>
                                    <p>Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, чтобы получить больше контроля над операциями с ними.</p>
                                    <code class="large">let user = {
    get name() {
        return this._name;
    },
    set name(value) {
        if (value.length &lt; 4) {
            console.log("Имя слишком короткое");
            return;
        }

        this._name = value;
    }
};

user.name = "Pete";
console.log(user.name); // Pete
user.name = ""; // Имя слишком короткое</code>
                                    <p>Таким образом, само имя хранится в <code>_name</code>, доступ к которому производится через геттер и сеттер.</p>
                                    <p>Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью <code>user._name</code>, но существует соглашение о том, что свойства, начинающиеся с символа <code>_</code>, являются внутренними, и к ним не следует обращаться из-за пределов объекта.</p>
                                    <h4>Использование для совместимости</h4>
                                    <p>Акцессоры позволяют в любой момент взять «обычное» свойство и изменить его поведение, поменяв на геттер и сеттер.</p>
                                    <p>Например, мы начали реализовывать объект <code>user</code>, используя свойства-данные <code>name</code> и <code>age</code>:</p>
                                    <code class="large">function User(name, age) {
    this.name = name;
    this.age = age;
}

let john = new User("John", 25);
console.log( john.age ); // 25</code>
                                    <p>Но рано или поздно вместо возраста <code>age</code> мы можем решить хранить дату рождения <code>birthday</code>, потому что так более точно и удобно:</p>
                                    <code class="large">function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;
}

let john = new User("John", new Date(1992, 6, 1));</code>
                                    <p>Что делать со старым кодом, который использует свойство <code>age</code>?</p>
                                    <p>Можно попытаться найти все такие места и изменить их, но это отнимет время и может быть невыполнимо, если код используется другими людьми. Кроме того, <code>age</code> – это отличное свойство для <code>user</code>. Сохраним его.</p>
                                    <p>Добавление геттера для <code>age</code> решит проблему:</p>
                                    <code class="large">function User(name, birthday) {
    this.name = name;
    this.birthday = birthday;

    Object.defineProperty(this, "age", {
        get() {
            let now = new Date();

            if (now.getMonth() &lt; this.birthday.getMonth() || now.getMonth() === this.birthday.getMonth() && now.getDate() &lt; this.birthday.getDate()) {
                return now.getFullYear() - this.birthday.getFullYear() - 1;
            }

            return now.getFullYear() - this.birthday.getFullYear();
        }
    });
}

let john = new User("John", new Date(1992, 7, 15));

console.log(john.birthday); // доступен и день рождения
console.log(john.age); // и возраст</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Прототипы, наследование</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="proto-inheritance" class="chapter__title">Прототипное наследование</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Прототипное наследование — это возможность языка, которая помогает повторно использовать свойства и методы объекта, не переопределяя их.</p>
                                    <h4>[[Prototype]]</h4>
                                    <p>Объекты имеют свойство <code>[[Prototype]]</code>, которое либо равно <code>null</code>, либо ссылается на другой объект («прототип»).</p>
                                    <p>Если свойство в объекте отсутствует, то возвращается одноименное свойство из прототипа. Такое свойство называется унаследованным.</p>
                                    <p>Свойство <code>__proto__</code> изменяет <code>[[Prototype]]</code> объекта. Ограничения:</p>
                                    <ol>
                                        <li>Ссылки не могут идти по кругу.</li>
                                        <li>Значение <code>__proto__</code> может быть объектом или <code>null</code>. Другие типы игнорируются.</li>
                                    </ol>
                                    <p>Метод <code>obj.hasOwnProperty(key)</code> возвращает <code>true</code>, если у <code>obj</code> есть собственное, не унаследованное, свойство с именем <code>key</code>.</p>
                                    <h5>Операция записи не использует прототип</h5>
                                    <p>Операции записи/удаления работают напрямую с объектом.</p>
                                    <p>Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.</p>
                                    <code class="large">let user = {
    name: "John",
    surname: "Smith",
  
    set fullName(value) {
        [this.name, this.surname] = value.split(" ");
    },
  
    get fullName() {
        return `${this.name} ${this.surname}`;
    }
};
  
let admin = {
    __proto__: user,
    isAdmin: true
};
  
console.log(admin.fullName); // John Smith
  
admin.fullName = "Alice Cooper";
console.log(admin.name); // Alice
console.log(admin.surname); // Cooper</code>
                                    <h4>Значение «this»</h4>
                                    <p>Не важно, где находится метод: в объекте или его прототипе. При вызове метода <code>this</code> — всегда объект перед точкой.</p>
                                    <p>Таким образом, вызов сеттера <code>admin.fullName</code> в качестве <code>this</code> использует <code>admin</code>, а не <code>user</code>.</p>
                                    <code class="large">let animal = {
    sleep() {
      this.isSleeping = true;
    }
};
  
let rabbit = {
    __proto__: animal
};
  
rabbit.sleep();
  
console.log(rabbit.isSleeping); // true
console.log(animal.isSleeping); // undefined</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="proto-function-prototype" class="chapter__title">F.prototype</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Новые объекты могут быть созданы с помощью функции-конструктора <code>new F()</code>.</p>
                                    <p>Если в <code>F.prototype</code> содержится объект, оператор <code>new</code> устанавливает его в качестве <code>[[Prototype]]</code> для нового объекта.</p>
                                    <p><code>F.prototype</code> - это обычное свойство с именем <code>"prototype"</code>. Оно устанавливает прототип объекта только в момент вызова <code>new F()</code>.</p>
                                    <code class="large">let animal = { eats: true };

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit");

console.log( rabbit.eats ); // true</code>
                                    <h4>F.prototype по умолчанию, свойство constructor</h4>
                                    <p>По умолчанию <code>prototype</code> – объект с единственным свойством <code>constructor</code>, которое ссылается на функцию-конструктор.</p>
                                    <code class="large">function Rabbit() {}
console.log( Rabbit.prototype.constructor == Rabbit ); // true</code>
                                    <p>Это удобно, когда есть объект, и неизвестно, какой конструктор использовался для его создания (например, он мог быть взят из сторонней библиотеки), а необходимо создать ещё один такой объект.</p>
                                    <code class="large">let obj2 = new obj1.constructor(args);</code>
                                    <p>Однако, если заменить прототип по умолчанию на другой объект, то свойства <code>constructor</code> в нём не будет.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="proto-native-prototypes" class="chapter__title">Встроенные прототипы</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Object.prototype</h4>
                                    <code class="large">alert( {} ); // [object Object]</code>
                                    <p><code>obj = {}</code> – это то же самое, что и <code>obj = new Object()</code>, где <code>Object</code> – встроенная функция-конструктор для объектов с собственным свойством <code>prototype</code>, которое ссылается на объект с методом <code>toString</code> и другими.</p>
                                    <p>Когда вызывается <code>new Object()</code> (или создаётся объект с помощью литерала <code>{...}</code>), свойство <code>[[Prototype]]</code> этого объекта устанавливается на <code>Object.prototype</code>.</p>
                                    <p>Таким образом, когда <code>alert</code> вызывает преобразование в примитив, метод <code>obj.toString()</code> берётся из <code>Object.prototype</code>.</p>
                                    <h4>Другие встроенные прототипы</h4>
                                    <p>Другие встроенные объекты, такие как <code>Array</code>, <code>Date</code>, <code>Function</code> и другие, также хранят свои методы в прототипах.</p>
                                    <p>Согласно спецификации, наверху иерархии встроенных прототипов находится <code>Object.prototype</code>.</p>
                                    <div class="ibg">
                                        <img src="img/JS/Прототипы, наследование/Наследование встроенных объектов.PNG" alt="Наследование встроенных объектов">
                                    </div>
                                    <p>При создании массива <code>[1, 2, 3]</code> используется конструктор массива <code>Array</code>. Поэтому прототипом массива становится <code>Array.prototype</code>.</p>
                                    <code class="large">let arr = [1, 2, 3];
console.log( arr.__proto__ === Array.prototype ); // true 
console.log( arr.__proto__.__proto__ === Object.prototype ); // true 
console.log( arr.__proto__.__proto__.__proto__ ); // null</code>
                                    <p>В браузерных инструментах, таких как консоль разработчика, можно посмотреть цепочку наследования, используя <code>console.dir</code>.</p>
                                    <h4>Примитивы</h4>
                                    <p>Примитивы - не объекты. Но если мы попытаемся получить доступ к их свойствам, будет создан временный объект-обёртка с использованием встроенных конструкторов <code>String</code>, <code>Number</code> и <code>Boolean</code>, который предоставит методы и после этого исчезнет.</p>
                                    <p>Методы этих объектов также находятся в прототипах, доступных как <code>String.prototype</code>, <code>Number.prototype</code> и <code>Boolean.prototype</code>.</p>
                                    <p>Специальные значения <code>null</code> и <code>undefined</code> не имеют объектов-обёрток. Также у них нет соответствующих прототипов.</p>
                                    <h5>Изменение встроенных прототипов</h5>
                                    <p>Встроенные прототипы можно изменять. Но их не рекомендуется менять, кроме как для создания полифилов.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="proto-methods" class="chapter__title">Методы прототипов, объекты без __proto__</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>__proto__</code> - устаревший геттер/сеттер для свойства <code>[[Prototype]]</code>. Современные же методы это:</p>
                                    <p><code>Object.create(proto, [descriptors])</code> – создаёт пустой объект со свойством <code>[[Prototype]]</code>, указанным как <code>proto</code>, и необязательными дескрипторами свойств <code>descriptors</code>.</p>
                                    <p><code>Object.getPrototypeOf(obj)</code> – возвращает свойство <code>[[Prototype]]</code> объекта <code>obj</code>.</p>
                                    <p><code>Object.setPrototypeOf(obj, proto)</code> – устанавливает свойство <code>[[Prototype]]</code> объекта <code>obj</code> как <code>proto</code>.</p>
                                    <p>У <code>Object.create</code> есть необязательный второй аргумент: дескрипторы свойств. Можно добавить дополнительное свойство новому объекту таким образом:</p>
                                    <code class="large">let animal = { eats: true };
  
let rabbit = Object.create(animal, {
    jumps: {
        value: true,
    }
});
  
console.log(rabbit.jumps); // true</code>
                                    <h5>Не нужно менять [[Prototype]] существующих объектов, если важна скорость</h5>
                                    <p><code>JavaScript</code> движки хорошо оптимизированы для того, чтобы устанавливвать прототип только во время создания объекта, после не меняя.</p>
                                    <p>Изменение прототипа «на лету» с помощью <code>Object.setPrototypeOf</code> или <code>obj.__proto__</code> – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта.</p>
                                    <h4>"Простейший" объект</h4>
                                    <p>Если хранить созданные пользователями ключи в качестве свойств объекта, окажется, что не все ключи работают как ожидается. Если пользователь введёт свойство <code>__proto__</code>, присвоение проигнорируется.</p>
                                    <code class="large">let obj = {};

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

console.log(obj[key] === Object.prototype); // true</code>
                                    <p>Неожиданные вещи могут случаться также при присвоении свойства <code>toString</code> и других свойств, которые являются встроенными методами.</p>
                                    <p>Такие ошибки являются сложными для отлавливания или даже становятся уязвимостями.</p>
                                    <p>Избежать проблемы можно, переключившись на использование коллекции <code>Map</code> или создав «простейший» (без прототипа) объект с помощью <code>Object.create(null)</code>.</p>
                                    <p>Кроме того, <code>Object.create</code> даёт лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:</p>
                                    <code class="large">let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Классы</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-syntax" class="chapter__title">Класс: базовый синтаксис</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Иногда нужно создавать много объектов одного вида, например пользователей, товары или что-то ещё. Конструкция «class» предоставляет новые возможности, полезные для объектно-ориентированного программирования.</p>
                                    <h4>Синтаксис «class»</h4>
                                    <p>Методы в классе не разделяются запятой:</p>
                                    <code class="large">class MyClass {
    prop = value;
    constructor() {}
    method(...) {}
    get something(...) {}
    set something(...) {}
    [Symbol.iterator]() {}
}</code>
                                    <p>Вызов <code>new MyClass()</code> создает новый объект со всеми перечисленными методами и запускает конструктор класса.</p>
                                    <p>Методы не записываются в объект, а находятся в свойстве <code>prototype</code> класса.</p>
                                    <code class="large">class User {
    constructor(name) { this.name = name; }
    sayHi() { console.log(this.name); }
}
  
console.log(typeof User); // function
console.log(Object.getOwnPropertyNames(User.prototype)); // ['constructor', 'sayHi']</code>
                                    <h5>Отличия классов от конструкторов:</h5>
                                    <ol>
                                        <li>Функция, созданная с помощью <code>class</code>, помечена специальным внутренним свойством <code>[[IsClassConstructor]]: true</code>. В отличие от обычных функций, конструктор класса не может быть вызван без <code>new</code>.</li>
                                        <li>Методы класса являются неперечислимыми. Определение класса устанавливает флаг <code>enumerable</code> в <code>false</code> для всех методов в <code>"prototype"</code>.</li>
                                        <li>Классы всегда используют <code>'use strict'</code>.</li>
                                    </ol>
                                    <h4>Class Expression</h4>
                                    <p>Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.</p>
                                    <code class="large">let User = class {};</code>
                                    <p>Аналогично Named Function Expression, Class Expression может иметь имя, которое не видно за его пределами.</p>
                                    <code class="large">let User = class MyClass {
    sayHi() {
        console.log(MyClass);
    }
};
  
new User().sayHi(); // class MyClass { ...
console.log(MyClass); // ReferenceError: MyClass is not defined</code>
                                    <h4>Геттеры/сеттеры</h4>
                                    <p>Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.</p>
                                    <p>При объявлении класса геттеры/сеттеры создаются на <code>User.prototype</code>.</p>
                                    <code class="large">class User {
    constructor(name) {
        this.name = name;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        if (value.length &lt; 4) {
            console.log("Имя слишком короткое.");
            return;
        }
        this._name = value;
    }
}
  
let user = new User("Иван");
console.log(user.name); // Иван

user = new User(''); // Имя слишком короткое.</code>
                                    <h4>Свойства классов</h4>
                                    <p>Свойство <code>name</code> создаётся оператором <code>new</code> перед запуском конструктора, это именно свойство объекта.</p>
                                    <code class="large">class User {
    name = "Аноним";
}

console.log( Object.keys( new User() ) ); // ['name']</code>
                                    <p>Свойства-функции класса, объявленные как <code>method = function() {}</code> также становятся свойствами объекта.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-inheritance" class="chapter__title">Наследование классов</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Ключевое слово «extends»</h4>
                                    <p><code>class Child extends Parent</code> - синтаксис для расширения другого класса.</p>
                                    <p>Ключевое слово <code>extends</code> устанавливает <code>Child.prototype.[[Prototype]]</code> в <code>Parent.prototype</code>.</p>
                                    <p>После <code>extends</code> разрешены любые выражения:</p>
                                    <code class="large">function f(phrase) {
    return class {
        sayHi() { console.log(phrase); }
    };
}
  
class User extends f("Привет") {}
  
new User().sayHi(); // Привет</code>
                                    <h4>Переопределение методов</h4>
                                    <p>Ключевое слово <code>super</code> позволяет создать метод класса, основываясь на родительском.</p>
                                    <p><code>super.method(...)</code> вызывает родительский метод.</p>
                                    <p><code>super(...)</code> для вызова родительского конструктора (работает только внутри нашего конструктора).</p>
                                    <code class="large">class Child extends Parent {
    someMethod() {
        super.someMethod();
        this.anotherMethod();
    }
}</code>
                                    <h4>Переопределение конструктора</h4>
                                    <p>Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой конструктор:</p>
                                    <code class="large">constructor(...args) {
    super(...args);
}</code>
                                    <p>Иначе конструктор должен обязательно вызывать <code>super(...)</code> и делать это перед использованием <code>this</code>.</p>
                                    <code class="large">class Parent {}
class Child extends Parent { constructor() {} }

console.log( new Child() ); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</code>
                                    <h4>Переопределение полей класса</h4>
                                    <p>Поле класса инициализируется:</p>
                                    <ul>
                                        <li>Перед конструктором для базового класса (который ничего не расширяет)</li>
                                        <li>Сразу после <code>super()</code> для производного класса</li>
                                    </ul>
                                    <code class="large">class Animal {
    name = 'animal';
  
    constructor() {
        console.log(this.name);
    }
}
  
class Rabbit extends Animal {
    name = 'rabbit';
}
  
new Animal(); // animal
new Rabbit(); // animal</code>
                                    <p>На момент вызова <code>console.log(this.name)</code> поле <code>name</code> родительского класса еще не было переопределено дочерним, поэтому вызов <code>new Rabbit()</code> возвращает <code>'animal'</code>.</p>
                                    <h4>Устройство super, [[HomeObject]]</h4>
                                    <p>Когда функция объявляется как метод внутри класса или объекта, она получает свойство <code>[[HomeObject]]</code>, равное этому объекту.</p>
                                    <code class="large">let animal = {
    name: "Животное",
    eat() { // animal.eat.[[HomeObject]] == animal
        console.log(`${this.name} ест.`);
    }
};

let rabbit = {
    __proto__: animal,
    name: "Кролик",
    eat() { // rabbit.eat.[[HomeObject]] == rabbit
        super.eat();
    }
};
  
let longEar = {
    __proto__: rabbit,
    name: "Длинноух",
    eat() { // longEar.eat.[[HomeObject]] == longEar
        super.eat();
    }
};

longEar.eat(); // Длинноух ест.</code>
                                    <p><code>[[HomeObject]]</code> нельзя изменить, эта связь – навсегда. Поэтому копировать метод, использующий <code>super</code>, между разными объектами небезопасно.</p>
                                    <h5>Методы, а не свойства-функции</h5>
                                    <p>Методы объекта, объявленные как "<code>method: function()</code>" не получают свойство <code>[[HomeObject]]</code>, поэтому им недоступно ключевое слово <code>super</code>.</p>
                                    <code class="large">let animal = {
    eat: function() {}
};
  
let rabbit = {
    __proto__: animal,
    eat: function() {
        super.eat();
    }
};
  
rabbit.eat(); // SyntaxError: 'super' keyword unexpected here</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-static" class="chapter__title">Статические свойства и методы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Можно присвоить метод самому классу. Такие методы называются статическими.</p>
                                    <code class="large">class User {
    static staticMethod() {
        console.log(this === User);
    }
}
  
User.staticMethod(); // true</code>
                                    <p>Это то же самое, что присвоить метод напрямую как свойство функции:</p>
                                    <code class="large">User.staticMethod = function() { ... }</code>
                                    <p>Статические свойства также возможны. Они были добавлены в язык позже:</p>
                                    <code class="large">class Article {
    static publisher = "Илья Кантор";
}
  
console.log( Article.publisher ); // Илья Кантор</code>
                                    <h4>Наследование статических свойств и методов</h4>
                                    <p>Статические свойства и методы наследуются.</p>
                                    <p>По умолчанию <code>[[Prototype]]</code> класса устанавливается в <code>Function.prototype</code>:</p>
                                    <code class="large">console.log(Function.__proto__ === Function.prototype); // true</code>
                                    <p>Ключевое слово <code>extends</code> дает дочернему классу ссылку <code>[[Prototype]]</code> на родительский.</p>
                                    <p>В результате наследование работает как для обычных, так и для статических методов.</p>
                                    <div class="ibg">
                                        <img src="img/JS/Классы/Наследование классов.PNG" alt="Наследование классов">
                                    </div>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-private" class="chapter__title">Приватные методы и свойства</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Приватные свойства и методы должны начинаться с <code>#</code>. Они доступны только внутри класса. К ним нельзя получить доступ извне или из наследуемых классов.</p>
                                    <p>Приватные поля не конфликтуют с публичными. Может быть два поля одновременно – приватное <code>#waterAmount</code> и публичное <code>waterAmount</code>.</p>
                                    <code class="large">class CoffeeMachine {
    #waterAmount = 0;

    get waterAmount() {
        return this.#waterAmount;
    }

    set waterAmount(value) {
        if (value &lt; 0) throw new Error("Отрицательный уровень воды");
        this.#waterAmount = value;
    }
}
  
let machine = new CoffeeMachine();
  
machine.waterAmount = 100;
console.log(machine.waterAmount); // 100
console.log(machine.#waterAmount); // SyntaxError: Private field '#waterAmount' must be declared in an enclosing class</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-extend-natives" class="chapter__title">Расширение встроенных классов</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Встроенные методы, такие как <code>filter</code>, <code>map</code> и другие возвращают объекты того же класса, к которому были применены.</p>
                                    <code class="large">class PowerArray extends Array {
    isEmpty() {
        return this.length === 0;
    }
}

let arr = new PowerArray(1, 2).map( item => item * 2);
console.log(arr.isEmpty()); // false
console.log(arr.constructor === PowerArray); // true</code>
                                    <p>При помощи статического геттера <code>Symbol.species</code> это поведение можно настроить:</p>
                                    <code class="large">class PowerArray extends Array {
    static get [Symbol.species]() {
        return Array;
    }
}

let arr = new PowerArray(1, 2).map( item => item * 2);
console.log(arr.constructor === Array); // true</code>
                                    <h4>Отсутствие статического наследования встроенных классов</h4>
                                    <p>Обычно, когда один класс наследует другой, то наследуются и статические методы. Но встроенные классы не наследуют статические методы друг друга.</p>
                                    <p>В этом отличие наследования встроенных объектов от наследования посредством <code>extends</code>.</p>
                                    <div class="ibg">
                                        <img src="img/JS/Классы/Наследование встроенных классов.PNG" alt="Наследование встроенных классов">
                                    </div>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-instanceof" class="chapter__title">Проверка класса: "instanceof"</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Оператор <code>instanceof</code> позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.</p>
                                    <h4>Оператор instanceof</h4>
                                    <p><code>obj instanceof Class</code> - вернёт <code>true</code>, если <code>obj</code> принадлежит классу <code>Class</code> или наследующему от него.</p>
                                    <p>То есть, он сравнивает <code>Class.prototype</code> с <code>obj.__proto__</code>, <code>obj.__proto__.__proto__</code> и тд.</p>
                                    <p>Но если <code>Class</code> имеет статический метод <code>Symbol.hasInstance</code>, то вызывается он: <code>instanceof</code> вернет <code>true</code>, если <code>Symbol.hasInstance</code> вернет <code>truthy</code>, иначе <code>false</code>.</p>
                                    <code class="large">class Animal {
    static [Symbol.hasInstance](obj) {
        if (obj.canEat) return true;
    }
}

let obj = { canEat: true };
console.log(obj instanceof Animal); // true</code>
                                    <p><code>objA.isPrototypeOf(objB)</code> - возвращает <code>true</code>, если <code>objA</code> равен <code>objB.__proto__</code>, либо <code>objB.__proto__.__proto__</code> и тд.</p>
                                    <p>То есть, без учета <code>Symbol.hasInstance</code>, <code>obj instanceof Class</code> равнозначно <code>Class.prototype.isPrototypeOf(obj)</code>.</p>
                                    <h4>Object.prototype.toString возвращает тип</h4>
                                    <p>Встроенный метод <code>toString</code> может быть позаимствован у объекта и вызван в контексте любого другого значения. Результат зависит от его типа.</p>
                                    <code class="large">console.log( {}.toString.call(alert) ); // [object Function]
console.log( {}.toString.call(null) ); // [object Null]</code>
                                    <h5>Symbol.toStringTag</h5>
                                    <p>Поведение метода объектов <code>toString</code> можно настраивать, используя специальное свойство объекта <code>Symbol.toStringTag</code>.</p>
                                    <code class="large">let user = {
    [Symbol.toStringTag]: "User"
};
  
console.log( {}.toString.call(user) ); // [object User]</code>
                                    <p>Такое свойство есть у большей части объектов, специфичных для определённых окружений.</p>
                                    <code class="large">console.log( {}.toString.call(window) ); // [object Window]</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="class-mixins" class="chapter__title">Примеси</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Примесь – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.</p>
                                    <p>В JavaScript реализовать примесь можно создав объект с полезными методами, которые затем могут быть легко добавлены в прототип любого класса.</p>
                                    <code class="large">let sayHiMixin = {
    sayHi() {
        console.log(`Привет, ${this.name}`);
    },
};
  
class User {
    constructor(name) {
        this.name = name;
    }
}
  
Object.assign(User.prototype, sayHiMixin);
  
new User("Вася").sayHi(); // Привет, Вася!</code>
                                    <p>Примеси могут наследовать друг друга.</p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Обработка ошибок</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="try-catch" class="chapter__title">Обработка ошибок, "try..catch"</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Синтаксис «try…catch»</h4>
                                    <p>Конструкция <code>try..catch</code> состоит из двух основных блоков: <code>try</code>, и затем <code>catch</code>:</p>
                                    <code class="large">try {
    // код...
} catch (err) {
    // обработка ошибки
}</code>
                                    <p>Сначала выполняется код внутри блока <code>try {...}</code>.</p>
                                    <p>Если в нём нет ошибок, то блок <code>catch(err)</code> игнорируется.</p>
                                    <p>Если же в нём возникает ошибка, то выполнение <code>try</code> прерывается, и поток управления переходит в начало <code>catch(err)</code>. Переменная <code>err</code> содержит объект ошибки с подробной информацией о произошедшем.</p>
                                    <code class="large">try {
    console.log(1); // 1
    lalala;
    console.log('Выполнение сюда не дойдет');
} catch(err) {
    console.log(err); // 'ReferenceError: lalala is not defined'
}</code>
                                    <p><code>try..catch</code> работает синхронно, поэтому не поймает исключение, которое произойдет, например, в <code>setTimeout</code>. Для этого <code>try..catch</code> должен находиться внутри запланированной функции:</p>
                                    <code class="large">setTimeout(function() {
    try {
        noSuchVariable;
    } catch {
        console.log("Ошибка поймана");
    }
}, 1000);</code>
                                    <h4>Объект ошибки</h4>
                                    <p>Для всех встроенных ошибок объект ошибки имеет два основных свойства:</p>
                                    <p><code>name</code> - имя ошибки. Например, <code>"ReferenceError"</code>.</p>
                                    <p><code>message</code> - текстовое сообщение о деталях ошибки.</p>
                                    <p>В целях отладки может использоваться нестандартное свойство <code>stack</code>, содержащее информацию о последовательности вложенных вызовов, которые привели к ошибке.</p>
                                    <h4>Генерация собственных ошибок</h4>
                                    <p>Оператор <code>throw</code> генерирует ошибку. Синтаксис:</p>
                                    <p><code>throw &lt;объект ошибки></code> - в качестве объекта ошибки можно передать что угодно, даже примитив, но лучше, чтобы это был объект со свойствами <code>name</code> и <code>message</code> для совместимости со встроенными ошибками.</p>
                                    <p>Есть множество встроенных конструкторов для стандартных ошибок: <code>Error</code>, <code>SyntaxError</code> и тд. Они генерируют объект ошибки, записывая в свойство <code>name</code> имя конструктора, а в <code>message</code> - содержимое аргумента:</p>
                                    <code class="large">let error = new Error("Ого, ошибка! o_O");
console.log(error.name); // Error
console.log(error.message); // Ого, ошибка! o_O</code>
                                    <h5>Проброс исключения</h5>
                                    <p>Блок <code>catch</code> предназначен для обработки только тех ошибок, которые ему известны. Остальные ошибки следует «пробрасывать» через <code>throw err</code>.</p>
                                    <code class="large">try {
    blabla(); // генерируется ReferenceError
} catch (e) {
    if (e.name !== 'SyntaxError') {
        throw e;
    }
}</code>
                                    <h5>try…catch…finally</h5>
                                    <p>Конструкция <code>try..catch</code> может содержать ещё одну секцию: <code>finally</code>. Если секция есть, то она выполнится после <code>try</code>, если ошибок не было, в противном случае после <code>catch</code>. Блок <code>finally</code> срабатывает при любом выходе из <code>try..catch</code>, в том числе и <code>return</code>.</p>
                                    <h5>try..finally без catch</h5>
                                    <p>Конструкция <code>try..finally</code> может применяться, когда мы не хотим обрабатывать ошибки, но хотим быть уверены, что начатые процессы завершились.</p>
                                    <h4>Глобальный catch</h4>
                                    <p>В случае, если произошла ошибка снаружи <code>try..catch</code>, и скрипт упал, мы хотим залогировать ошибку, показать что-то пользователю и тд.</p>
                                    <p>Способа сделать это нет в спецификации, но обычно окружения предоставляют его. В <code>Node.js</code> для этого есть <code>process.on("uncaughtException")</code>. В браузере можно присвоить функцию специальному свойству <code>window.onerror</code>, которая будет вызвана в случае необработанной ошибки.</p>
                                    <code class="large">window.onerror = function(message, url, line, col, error) {
    // ...
};</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="custom-errors" class="chapter__title">Пользовательские ошибки, расширение Error</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Мы можем наследовать свои классы ошибок от <code>Error</code> и других встроенных классов ошибок, так как за счет наследования появляется возможность идентификации объектов ошибок посредством <code>obj instanceof Error</code>.</p>
                                    <p>"Псевдокод" встроенного класса <code>Error</code>, определённого самим JavaScript:</p>
                                    <code class="large">class Error {
    constructor(message) {
        this.message = message;
        this.name = "Error";
        this.stack = &lt;стек вызовов>;
    }
}</code>
                                    <p>Например, создадим класс <code>ValidationError</code> для идентификации JSON-данных в неверном формате. Поскольку <code>ValidationError</code> является слишком общим, добавим более конкретный класс <code>PropertyRequiredError</code>, который будет нести более подробную информацию об отсутствующем свойстве.</p>
                                    <code class="large">class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}
  
class PropertyRequiredError extends ValidationError {
    constructor(property) {
        super("Нет свойства: " + property);
        this.property = property;
    }
}</code>
                                    <p>Применение:</p>
                                    <code class="large">function readUser(json) {
    let user = JSON.parse(json);
  
    if (!user.name) {
        throw new PropertyRequiredError("name");
    }
  
    return user;
}

try {
    let user = readUser('{ "age": 25 }');
} catch (err) {
    if (err instanceof ValidationError) {
        console.log("Неверные данные. " + err.message); // Неверные данные. Нет свойства: name
        console.log(err.name); // PropertyRequiredError
        console.log(err.property); // name
    } else if (err instanceof SyntaxError) {
        console.log("Ошибка синтаксиса JSON: " + err.message);
    } else {
        throw err;
    }
}</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Промисы, async/await</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="promise-basics" class="chapter__title">Промисы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Синтаксис создания промиса:</p>
                                    <code class="large">let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
});</code>
                                    <p>Функция-исполнитель выполняется синхронно и когда она получит результат (обычно не сразу), должна вызвать <code>resolve</code> или <code>reject</code> - колбеки, которые предоставляет сам JavaScript.</p>
                                    <p><code>resolve(value)</code> — если работа завершилась успешно, с результатом <code>value</code>.</p>
                                    <p><code>reject(error)</code> — если произошла ошибка, <code>error</code> – объект ошибки.</p>
                                    <p>У объекта <code>promise</code>, возвращаемого конструктором <code>new Promise</code>, есть внутренние свойства:</p>
                                    <p><code>state</code> — состояние промиса, может иметь одно из трех значений:</p>
                                    <ul>
                                        <li><code>"pending"</code> («ожидание») - начальное состояние</li>
                                        <li><code>"fulfilled"</code> («выполнен») - состояние после вызова <code>resolve</code></li>
                                        <li><code>"rejected"</code> («отклонен») - состояние после вызова <code>reject</code></li>
                                    </ul>
                                    <p><code>result</code> — результат выполнения, <code>undefined</code> если промис в состоянии <code>"pending"</code>, иначе значение, которое было передано в колбек <code>resolve</code> или <code>reject</code>.</p>
                                    <p>При вызове колбека <code>resolve</code>/<code>reject</code> промис изменяет состояние. Состояние промиса может быть изменено только один раз.</p>
                                    <h4>Потребители: then, catch</h4>
                                    <p>Методы <code>then</code> и <code>catch</code> ждут выполнения промиса, если он находится в состоянии <code>"pending"</code>, иначе запускаются сразу.</p>
                                    <h5>then</h5>
                                    <code class="large">promise.then(
    function(result) { /* ... */ }, // вызывается, если промис перешел в состояние 'fulfilled'
    function(error) { /* ... */ } // вызывается, если промис перешел в состояние 'rejected'
);</code>
                                    <p>Если обрабатывать отклоненный промис не нужно, в <code>then</code> можно передать только один аргумент.</p>
                                    <p>Если нужно обработать только ошибку, можно использовать <code>null</code> в качестве первого аргумента, либо воспользоваться методом <code>catch</code>.</p>
                                    <h5>catch</h5>
                                    <code class="large">promise.catch(f) - это сокращённый вариант promise.then(null, f).</code>
                                    <h4>Очистка: finally</h4>
                                    <p>Вызов <code>.finally(f)</code> похож на <code>.then(f, f)</code>, в том смысле, что <code>f</code> выполнится в любом случае. Обычно его задача – выполнить «общие» завершающие процедуры.</p>
                                    <p>Обработчик, вызываемый из <code>finally</code>, не получает результат предыдущего обработчика. Он «пропускает» результат или ошибку дальше, к последующим обработчикам:</p>
                                    <code class="large">new Promise((resolve, reject) => {
    setTimeout(() => resolve(2), 2000);
})
.finally(() => console.log(1)) // 1, срабатывает первым
.then(result => console.log(result)); // 2</code>
                                    <p>Значение, возвращаемое <code>finally</code>, игнорируется. Однако, если <code>finally</code> завершится с ошибкой, эта ошибка будет передана следующему обработчику вместо предыдущего результата.</p>
                                    <p>Обработчики промисов <code>.then</code> / <code>.catch</code> / <code>.finally</code> всегда асинхронны.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="promise-chaining" class="chapter__title">Цепочка промисов</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Обработчик <code>handler</code>, переданный в <code>.then(handler)</code>, может вернуть промис. В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.</p>
                                    <p>Как правило, все асинхронные действия должны возвращать промис. Это позволяет планировать после него какие-либо дополнительные действия.</p>
                                    <h5>Thenable</h5>
                                    <p>Обработчик может возвращать любой объект, содержащий метод <code>then</code>, и этот объект будет обработан как промис. Такие объекты называют «thenable».</p>
                                    <code class="large">class Thenable {
    constructor(num) {
        this.num = num;
    }
    then(resolve, reject) {
        console.log(0);
        setTimeout(() => resolve(this.num * 2), 1000);
    }
}
  
Promise.resolve(1)
    .then(result => {
        return new Thenable(result); // 0, сразу
    })
    .then(result => console.log(result)); // 2, через секунду</code>
                                    <p>JavaScript проверяет объект, возвращаемый из обработчика <code>.then</code>, если тот содержит метод <code>then</code>, который можно вызвать, то он вызывается, и в него передаются как аргументы встроенные функции <code>resolve</code> и <code>reject</code>, вызов одной из которых потом ожидается. Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от <code>Promise</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="promise-error-handling" class="chapter__title">Промисы: обработка ошибок</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Самый лёгкий путь перехватить ошибку – добавить <code>catch</code> в конец цепочки промисов.</p>
                                    <h4>Неявный try…catch</h4>
                                    <p>Если сгенерировать ошибку с помощью <code>throw</code> внутри функции-обработчика, промис будет считаться отклонённым с этой ошибкой. Эти два примера дают одинаковый результат:</p>
                                    <code class="large">new Promise((resolve, reject) => {
    throw new Error("Ошибка!");
}).catch(err => console.log(err)); // Error: Ошибка!

new Promise((resolve, reject) => {
    reject(new Error("Ошибка!"));
}).catch(err => console.log(err)); // Error: Ошибка!</code>
                                    <p>"Невидимый <code>try..catch</code>" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.</p>
                                    <h4>Пробрасывание ошибок</h4>
                                    <p>В обычном <code>try..catch</code> мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать.</p>
                                    <p>То же самое возможно для промисов.</p>
                                    <code class="large">new Promise((resolve, reject) => {
    throw new Error("Ошибка!");
})
.catch(function(err) { 
    if (err instanceof URIError) {
        // обрабатываем ошибку
    } else { 
        throw err;
    }
  
})
.then(function() { /* не выполнится */ })
.catch(error => {
    console.log(`Неизвестная ошибка: ${error}`); 
});</code>
                                    <h4>Необработанные ошибки</h4>
                                    <p>Если ошибка в промисе не была перехвачена (не обработана в конце очереди микрозадач), скрипт умирает с сообщением в консоли.</p>
                                    <p>В браузере можно поймать такие ошибки, используя событие <code>unhandledrejection</code>. Объект события имеет два специальных свойства:</p>
                                    <ul>
                                        <li><code>promise</code> - промис, который сгенерировал ошибку</li>
                                        <li><code>reason</code> - объект ошибки, которая не была обработана</li>
                                    </ul>
                                    <code class="large">window.addEventListener('unhandledrejection', function(event) {
    console.log(event.promise); // Promise &lt;rejected>: Error: Ошибка!
    console.log(event.reason); // Error: Ошибка!
});

new Promise(function() {
    throw new Error("Ошибка!");
});</code>
                                    <p>Обычно такие ошибки неустранимы, поэтому лучше информировать пользователя о проблеме и отправить информацию об ошибке на сервер.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="promise-api" class="chapter__title">Promise API</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>В классе <code>Promise</code> есть 6 статических методов.</p>
                                    <h4>Promise.all</h4>
                                    <p><code>Promise.all(iterable)</code> - принимает перебираемый объект с промисами (разрешено передавать не-промисы) и возвращает новый промис. Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.</p>
                                    <code class="large">Promise.all([1, new Promise( r => setTimeout(() => r(2), 1000) ), 3])
.then(result => console.log(result)); // [1, 2, 3]</code>
                                    <p>Частый прием - пропустить массив данных через map-функцию, возвращающую промис для каждого элемента, затем обернуть получившийся массив в <code>Promise.all</code>.</p>
                                    <p>Если любой из промисов завершится с ошибкой, то промис, возвращённый <code>Promise.all</code>, немедленно завершается с этой ошибкой.</p>
                                    <h4>Promise.allSettled</h4>
                                    <p><code>Promise.allSettled(iterable)</code> - всегда ждет завершения всех промисов. В массиве результатов будет:</p>
                                    <p><code>{status: "fulfilled", value: any}</code> - для успешно завершившихся промисов.</p>
                                    <p><code>{status: "rejected", reason: err}</code> - для промисов с ошибкой.</p>
                                    <p>Если браузер не поддерживает <code>Promise.allSettled</code>, для него легко сделать полифил:</p>
                                    <code class="large">if (!Promise.allSettled) {
    Promise.allSettled = function(promises) {
        return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
            status: 'fulfilled',
            value: value
        }), error => ({
            status: 'rejected',
            reason: error
        }))));
    };
}</code>
                                    <h4>Promise.race</h4>
                                    <p><code>Promise.race(iterable)</code> - ждёт только первый выполненный промис.</p>
                                    <code class="large">Promise.race([
    new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
    new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
    new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(result => console.log(result)); // 1</code>
                                    <h4>Promise.any</h4>
                                    <p><code>Promise.any(iterable)</code> - ждет только первый успешно выполенный промис. Если ни один из переданных промисов не завершится успешно, тогда возвращённый промис будет отклонён с помощью <code>AggregateError</code> – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве <code>errors</code>.</p>
                                    <code class="large">Promise.any([
    new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
    new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
]).catch(err => console.log(err)); // AggregateError: All promises were rejected</code>
                                    <h4>Promise.resolve/reject</h4>
                                    <p><code>Promise.resolve(value)</code> создаёт успешно выполненный промис с результатом <code>value</code>.</p>
                                    <p><code>Promise.reject(error)</code> создаёт промис, завершённый с ошибкой <code>error</code>.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="promise-async-await" class="chapter__title">Async/await</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Ключевое слово <code>async</code> перед объявлением функции (или метода) обязывает её всегда возвращать промис и позволяет использовать <code>await</code> в теле этой функции.</p>
                                    <p><code>await</code> может использоваться только в <code>async</code> функциях и на верхнем уровне модулей (глобально).</p>
                                    <p>Ключевое слово <code>await</code> заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от <code>await</code> не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.</p>
                                    <p>Если промис завершится с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось <code>throw</code>.</p>
                                    <p>Такие ошибки можно ловить, используя <code>try..catch</code>, как с обычным <code>throw</code>:</p>
                                    <code class="large">(async () => {
    try {
        await fetch('http://no-such-url');
    } catch(err) {
        console.log(err); // TypeError: failed to fetch
    }
})()</code>
                                    <p>Если нет <code>try..catch</code>, асинхронная функция будет возвращать завершившийся с ошибкой промис. В этом случае можно будет использовать метод <code>.catch</code>, чтобы обработать ошибку: <code>f().catch(/* ... */)</code>.</p>
                                    <p><code>async/await</code> отлично работает с <code>Promise.all</code>:</p>
                                    <code class="large">let results = await Promise.all([
    fetch(url1),
    fetch(url2),
]);</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Генераторы, продвинутая итерация</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="generators" class="chapter__title">Генераторы</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Функция-генератор</h4>
                                    <p><code>function*</code> - конструкция, объявляющая функцию-генератор. Когда функция-генератор вызывается, она возвращает специальный объект - генератор.</p>
                                    <p>Генератор имеет метод <code>next()</code>, при вызове которого запускается выполнение кода до ближайшей инструкции <code>yield &lt;значение></code> (при отсутствии значения, оно предполагается равным <code>undefined</code>). По достижении <code>yield</code> выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код.</p>
                                    <p>Результатом метода <code>next()</code> всегда является объект с двумя свойствами:</p>
                                    <p><code>value</code> - значение из <code>yield</code>.</p>
                                    <p><code>done</code> - <code>true</code>/<code>false</code>. <code>true</code> если выполнение функции завершено, иначе <code>false</code>.</p>
                                    <code class="large">function* generateSequence() {
    yield 1;
    return 2;
}

let generator = generateSequence();
console.log(generator.toString()); // [object Generator]

console.log(generator.next()); // {value: 1, done: false}
console.log(generator.next()); // {value: 2, done: true}
console.log(generator.next()); // {value: undefined, done: true}</code>
                                    <h5>Перебор генераторов</h5>
                                    <p>Генераторы являются перебираемыми объектами.</p>
                                    <code class="large">function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
}

for (let value of generateSequence()) {
    console.log(value); // 1, затем 2
}</code>
                                    <h5>Использование генераторов для перебираемых объектов</h5>
                                    <p>Генераторы были добавлены в язык JavaScript, в частности, с целью упростить создание перебираемых объектов:</p>
                                    <code class="large">let range = {
    from: 1,
    to: 5,
  
    *[Symbol.iterator]() { // краткая запись для [Symbol.iterator]: function*()
        for (let value = this.from; value &lt;= this.to; value++) {
            yield value;
        }
    }
};
  
console.log( [...range] ); //  [1, 2, 3, 4, 5]</code>
                                    <h4>Композиция генераторов</h4>
                                    <p>Для генераторов есть особый синтаксис <code>yield*</code>, который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).</p>
                                    <code class="large">function* generateSequence(start, end) {
    for (let i = start; i &lt;= end; i++) yield i;
}
  
function* generatePasswordCodes() {
    yield* generateSequence(48, 57);
  
    yield* generateSequence(65, 90);

    yield* generateSequence(97, 122);
  
}
  
let str = '';
  
for(let code of generatePasswordCodes()) {
    str += String.fromCharCode(code);
}
  
console.log(str); // 0123456789A..Za..z</code>
                                    <h4>yield – дорога в обе стороны</h4>
                                    <p><code>yield</code> – не только возвращает результат, но и может передавать значение извне в генератор.</p>
                                    <code class="large">function* gen() {
    let ask1 = yield "2 + 2 = ?";
    console.log(ask1); // 4
  
    let ask2 = yield "3 * 3 = ?"
    console.log(ask2); // 9
}
  
let generator = gen();
console.log( generator.next().value ); // "2 + 2 = ?"
console.log( generator.next(4).value ); // "3 * 3 = ?"
console.log( generator.next(9).done ); // true</code>
                                    <h4>generator.throw</h4>
                                    <p>Можно передать не только результат, но и инициировать ошибку. Чтобы передать ошибку в <code>yield</code>, нужно вызвать <code>generator.throw(err)</code>. В таком случае исключение <code>err</code> возникнет на строке с <code>yield</code>.</p>
                                    <code class="large">function* gen() {
    try {
        let result = yield "2 + 2 = ?";
        console.log("Выполнение не дойдёт до этой строки");
    } catch(e) {
        console.log(e); // Error: Ответ не найден в моей базе данных
    }
}

let generator = gen();
  
console.log( generator.next().value ); // 2 + 2 = ?
generator.throw(new Error("Ответ не найден в моей базе данных"));</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="generators-async-iterators" class="chapter__title">Асинхронные итераторы и генераторы</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Асинхронные итераторы</h4>
                                    <p>Чтобы сделать объект итерируемым асинхронно:</p>
                                    <ol>
                                        <li>Используется <code>Symbol.asyncIterator</code> вместо <code>Symbol.iterator</code>.</li>
                                        <li><code>next()</code> должен возвращать промис.</li>
                                        <li>Чтобы перебрать такой объект, используется цикл <code>for await (let item of iterable)</code>.</li>
                                    </ol>
                                    <code class="large">let range = {
    from: 1,
    to: 5,
  
    [Symbol.asyncIterator]() {
        return {
            current: this.from,
            last: this.to,
  
            async next() {
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (this.current &lt;= this.last) {
                    return { done: false, value: this.current++ };
                } else {
                    return { done: true };
                }
            }
        };
    }
};
  
(async () => {
    for await (let value of range) {
        console.log(value); // через секунду 1, затем через секунду 2, ... 5
    }
})();</code>
                                    <h4>Асинхронные генераторы</h4>
                                    <p><code>async function*</code> создает асинхронную функцию-генератор, при вызове функция создает генератор, который можно перебирать с помощью <code>for await .. of</code>.</p>
                                    <code class="large">async function* generateSequence(start, end) {
    for (let i = start; i &lt;= end; i++) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        yield i;
    }
}
  
(async () => {
    let generator = generateSequence(1, 5);
    for await (let value of generator) {
        console.log(value); // через секунду 1, затем через секунду 2, ... 5
    }
})();</code>
                                    <p><code>Метод generator.next()</code> теперь тоже асинхронный и возвращает промисы.</p>
                                    <h4>Асинхронно перебираемые объекты</h4>
                                    <p><code>Symbol.asyncIterator</code> может возвращать генератор, а не простой объект с методом <code>next</code>.</p>
                                    <code class="large">let range = {
    from: 1,
    to: 5,
  
    async *[Symbol.asyncIterator]() { // то же, что [Symbol.asyncIterator]: async function*()
        for (let value = this.from; value &lt;= this.to; value++) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            yield value;
        }
    }
};
</code>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Модули</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="modules-intro" class="chapter__title">Модули, введение</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>Что такое модуль?</h4>
                                    <p>Модуль – это просто файл. Один скрипт – это один модуль.</p>
                                    <p>Модули могут загружать друг друга и использовать директивы <code>export</code> и <code>import</code>, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:</p>
                                    <ul>
                                        <li><code>export</code> отмечает переменные и функции, которые должны быть доступны вне текущего модуля</li>
                                        <li><code>import</code> позволяет брать функциональность из других модулей</li>
                                    </ul>
                                    <p>📁 sayHi.js:</p>
                                    <code class="large">export function sayHi() { console.log('hi') };</code>
                                    <p>📁 main.js:</p>
                                    <code class="large">import {sayHi} from './sayHi.js';
sayHi(); // hi</code>
                                    <h4>Основные возможности модулей</h4>
                                    <p>В модулях всегда используется режим <code>'use strict'</code>.</p>
                                    <p>Каждый модуль имеет свою собственную область видимости. Переменные и функции, объявленные в модуле, не видны в других скриптах. При необходимости сделать глобальную переменную, можно явно присвоить её объекту <code>window</code>.</p>
                                    <h5>Код в модуле выполняется только один раз при импорте</h5>
                                    <p>📁 sayHi.js: </p>
                                    <code class="large">console.log('hi'); // hi</code>
                                    <p>📁 main.js:</p>
                                    <code class="large">import './sayHi.js';</code>
                                    <p>📁 another.js:</p>
                                    <code class="large">import './sayHi.js';</code>
                                    <h5>import.meta</h5>
                                    <code class="large">console.log(import.meta.url); // ссылка на html страницу для встроенного скрипта, либо ссылка на файл со скриптом для внешнего</code>
                                    <h4>Особенности в браузерах</h4>
                                    <p>Модули являются отложенными (deferred), точно так же, как скрипты с атрибутом <code>defer</code>.</p>
                                    <p>Для модулей атрибут <code>async</code> работает на любых скриптах, модуль выполнится сразу после загрузки, не ожидая других скриптов.</p>
                                    <h5>Внешние скрипты</h5>
                                    <p>Внешние скрипты с атрибутом <code>type="module"</code> имеют два отличия от обычных скриптов.</p>
                                    <p>Внешние скрипты с одинаковым атрибутом <code>src</code> запускаются только один раз.</p>
                                    <p>Если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена, иначе скрипт не выполнится.</p>
                                    <h5>Совместимость, «nomodule»</h5>
                                    <p>Старые браузеры не понимают атрибут <code>type="module"</code>. Скрипты с неизвестным атрибутом <code>type</code> просто игнорируются. Можно сделать для них «резервный» скрипт при помощи атрибута <code>nomodule</code>.</p>
                                    <code class="large">&lt;script nomodule>
    console.log('Современные браузеры не выполнят этот скрипт');
&lt;/script></code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="modules-import-export" class="chapter__title">Экспорт и импорт</h3>
                                </div>
                                <div class="chapter__content">
                                    <h5>Экспорт до объявления</h5>
                                    <code class="large">export const MODULES_BECAME_STANDARD_YEAR = 2015;</code>
                                    <h5>Экспорт отдельно от объявления</h5>
                                    <p>📁 say.js</p>
                                    <code class="large">let sayHi = user => console.log(`Hello, ${user}`);
let sayBye = user => console.log(`Bye, ${user}`);

export {sayHi, sayBye};</code>
                                    <h5>Импорт *</h5>
                                    <p>📁 main.js</p>
                                    <code class="large">import * as say from './say.js';

say.sayHi('John'); // Hello, John
say.sayBye('John'); // Bye, John</code>
                                    <h5>Импорт «как»</h5>
                                    <code class="large">import {sayHi as hi, sayBye as bye} from './say.js';</code>
                                    <h5>Экспортировать «как»</h5>
                                    <p>📁 say.js</p>
                                    <code class="large">export {sayHi as hi, sayBye as bye};</code>
                                    <p>📁 main.js</p>
                                    <code class="large">import {hi, bye} from './say.js';

hi('John'); // Hello, John!
bye('John'); // Bye, John!</code>
                                    <h4>Экспорт по умолчанию</h4>
                                    <p>На практике часто встречаются модули, которые объявляют что-то одно. Для этого подхода есть специальный синтаксис - <code>export default</code> («экспорт по умолчанию»).</p>
                                    <p>📁 user.js</p>
                                    <code class="large">export default class User {
    constructor(name) {
        this.name = name;
    }
}</code>
                                    <p>📁 main.js</p>
                                    <code class="large">import User from './user.js';
console.log( new User('John') ); // {name: 'John'}</code>
                                    <p>Так как в файле может быть максимум один <code>export default</code>, то экспортируемая сущность не обязана иметь имя.</p>
                                    <code class="large">export default [1, 2, 3];</code>
                                    <p>Чтобы соблюсти единообразие кода, принято давать соответствующие имена импортируемым переменным:</p>
                                    <code class="large">import LoginForm from './loginForm.js';
import func from '/path/to/func.js';</code>
                                    <h5>Имя «default»</h5>
                                    <p>Экспорт по умолчанию отдельно от объявления экспортируемой сущности:</p>
                                    <code class="large">let sayHi = user => console.log(`Hello, ${user}!`);
export {sayHi as default};</code>
                                    <p>Экспорт по умолчанию вместе с именованным экспортом:</p>
                                    <p>📁 user.js</p>
                                    <code class="large">export default class User {
    constructor(name) {
        this.name = name;
    }
}
  
export let sayHi = user => console.log(`Hello, ${user}!`);</code>
                                    <p>Примеры импорта такого экспорта:</p>
                                    <p>📁 main.js</p>
                                    <code class="large">import {default as User, sayHi} './user.js';</code>
                                    <p>📁 main.js</p>
                                    <code class="large">import User, {sayHi} from './user.js';</code>
                                    <p>📁 main.js</p>
                                    <code class="large">import * as user from './user.js';
let User = user.default;
console.log(new User('John')); // {name: 'John'}
user.sayHi('Pete'); // Hello, Pete!</code>
                                    <h4>Реэкспорт</h4>
                                    <p>Синтаксис «реэкспорта» <code>export ... from ...</code> позволяет импортировать что-то и тут же экспортировать, возможно под другим именем:</p>
                                    <code class="large">import {login, logout} from 'auth/index.js'; // без инициализации этих переменных в промежуточном файле</code>
                                    <h5>Реэкспорт экспорта по умолчанию</h5>
                                    <p>Чтобы реэкспортировать экспорт по умолчанию, нужно написать <code>export {default as User}</code> или <code>export {default}</code> для реэкспорта по умолчанию.</p>
                                    <p>Реэкспорт именованных экспортов и экспортов по умолчанию одновременно:</p>
                                    <code class="large">export {default as User, sayHi} from './user.js';</code>
                                    <p>Или используя две инструкции:</p>
                                    <code class="large">export * from './user.js'; // реэкспортирует только именованные экспорты
export {default} from './user.js';</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="modules-dynamic-imports" class="chapter__title">Динамические импорты</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Выражение <code>import(module)</code> загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.</p>
                                    <p>Использовать его можно динамически в любом месте кода:</p>
                                    <code class="large">let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
    .then(obj => &lt;объект модуля>)
    .catch(err => &lt;ошибка загрузки, например если нет такого модуля>)</code>
                                    <p>Используя <code>async</code>/<code>await</code>: <code>let module = await import(modulePath)</code>.</p>
                                    <code class="large">let {sayHi, default: User} = await import('./first.js');
sayHi();
let user = new User("John");</code>
                                    <p>Динамический импорт работает в обычных скриптах, он не требует указания <code>type="module"</code>.</p>
                                </div>
                            </section>
                        </div>
                    </section>
                    <section class="content__section">
                        <div class="content__header">
                            <h2 class="content__title">Разное</h2>
                        </div>
                        <div class="content__body">
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="proxy" class="chapter__title">Proxy и Reflect</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Особый, «экзотический» объект <code>Proxy</code> не имеет собственных свойств. Он «оборачивается» вокруг другого объекта и может перехватывать и обрабатывать разные действия с ним.</p>
                                    <code class="large">let proxy = new Proxy(target, handler);</code>
                                    <p><code>target</code> – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.</p>
                                    <p><code>handler</code> – конфигурация прокси - объект с «ловушками» («traps»), то есть методами, которые перехватывают разные операции.</p>
                                    <p>При операциях над <code>proxy</code>, если в <code>handler</code> имеется соответствующая «ловушка», она срабатывает, и прокси имеет возможность по-своему обработать её, иначе операция будет совершена над оригинальным объектом <code>target</code>.</p>
                                    <code class="large">let target = {};
let proxy = new Proxy(target, {}); // прокси без ловушек

proxy.test = 5;
console.log(target.test); // 5
console.log(proxy.test); // 5
for (let key in proxy) console.log(key); // test</code>
                                    <p>Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять.</p>
                                    <p>Например, <code>[[Get]]</code> – внутренний метод для чтения свойства, <code>[[Set]]</code> – для записи и тд.</p>
                                    <p>Ловушки перехватывают вызовы этих внутренних методов. Полный список методов, которые можно перехватывать, перечислен в таблице. Для каждого внутреннего метода указана ловушка, то есть имя метода, который можно добавить в параметр <code>handler</code> при создании <code>new Proxy</code>, чтобы перехватывать данную операцию.</p>
                                    <div class="ibg">
                                        <img src="img/JS/Разное/Proxy/ловушки.JPG" alt="Ловушки Proxy">
                                    </div>
                                    <p>JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.</p>
                                    <p><code>[[Set]]</code> должен возвращать <code>truthy</code>, если значение было успешно записано, иначе <code>falsish</code>.</p>
                                    <p><code>[[Delete]]</code> должен возвращать <code>truthy</code>, если значение было успешно удалено, иначе <code>falsish</code>.</p>
                                    <p><code>[[GetPrototypeOf]]</code> должен возвращать то же значение, что и <code>[[GetPrototypeOf]]</code>, применённый к оригинальному объекту (чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта).</p>
                                    <p>Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия.</p>
                                    <p>Инварианты гарантируют корректное и последовательное поведение конструкций и методов языка.</p>
                                    <h4>Значение по умолчанию с ловушкой «get»</h4>
                                    <p><code>get(target, property, receiver)</code> - метод для перехвата операции чтения.</p>
                                    <p><code>target</code> – оригинальный объект, который передавался первым аргументом в конструктор <code>new Proxy</code>.</p>
                                    <p><code>property</code> – имя свойства.</p>
                                    <p><code>receiver</code> – обычно сам объект прокси (или наследующий от него объект). Аргумент имеет значение, только если свойство – геттер.</p>
                                    <p>Например, есть объект-словарь с фразами на английском и их переводом на испанский.</p>
                                    <p>Сделаем так, чтобы при отсутствии перевода возвращалась оригинальная фраза на английском вместо <code>undefined</code>.</p>
                                    <p>Также прокси должен заменить собой оригинальный объект чтобы не запутаться в дальнейшем.</p>
                                    <code class="large">let dictionary = {
    'Hello': 'Hola',
    'Bye': 'Adiós'
};

dictionary = new Proxy(dictionary, {
    get(target, prop) {
        if (prop in target) return target[prop];
        return prop;
    }
});

console.log( dictionary['Hello'] ); // Hola
console.log( dictionary['Welcome'] ); // Welcome</code>
                                    <h4>Валидация с ловушкой «set»</h4>
                                    <p><code>set(target, property, value, receiver)</code> - ловушка, срабатывающая при записи свойства.</p>
                                    <p><code>target</code> – оригинальный объект, который передавался первым аргументом в конструктор <code>new Proxy</code>.</p>
                                    <p><code>property</code> – имя свойства.</p>
                                    <p><code>value</code> – значение свойства.</p>
                                    <p><code>receiver</code> – обычно сам объект прокси (или наследующий от него объект). Аргумент имеет значение, только если свойство – сеттер.</p>
                                    <p>Допустим, мы хотим сделать массив исключительно для чисел. Если в него добавляется значение иного типа, то это должно приводить к ошибке.</p>
                                    <code class="large">let numbers = [];

numbers = new Proxy(numbers, {
    set(target, prop, value) {
        if (typeof value === 'number') {
            target[prop] = value;
            return true;
        }
    }
});

numbers.push(50); // добавилось успешно
numbers.push("тест"); // TypeError: 'set' on proxy: trap returned falsish for property '2'</code>
                                    <p>Встроенная функциональность массива по-прежнему работает. Методы массива внутри себя используют операцию <code>[[Set]]</code>, которая перехватывается прокси. Таким образом, код остаётся чистым и прозрачным.</p>
                                    <p>Если забыть вернуть <code>truthy</code> в случае успешной записи свойства, это приведёт к ошибке <code>TypeError</code>.</p>
                                    <h4>Перебор при помощи «ownKeys» и «getOwnPropertyDescriptor»</h4>
                                    <p><code>Object.keys</code>, цикл <code>for..in</code> и большинство других методов, работающих со списком свойств объекта, используют внутренний метод <code>[[OwnPropertyKeys]]</code> (перехватываемый ловушкой <code>ownKeys</code>) для их получения.</p>
                                    <p>В примере ниже мы используем ловушку <code>ownKeys</code>, чтобы цикл <code>for..in</code> по объекту, равно как <code>Object.keys</code> и <code>Object.values</code> пропускали свойства, начинающиеся с подчёркивания _:</p>
                                    <code class="large">let user = {
    name: "Вася",
    age: 30,
    _password: "***"
};

user = new Proxy(user, {
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'));
    }
});

console.log( Object.keys(user) ); // ['name', 'age']
console.log( Object.values(user) ); // ['Вася', 30]</code>
                                    <p>Впрочем, если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то <code>Object.keys</code> его не выдаст:</p>
                                    <code class="large">let user = {};

user = new Proxy(user, {
    ownKeys(target) {
        return ['a', 'b', 'c'];
    }
});

console.log( Object.keys(user) ); // []</code>
                                    <p>Причина такова: <code>Object.keys</code> возвращает только свойства с флагом <code>enumerable</code>. Для того, чтобы определить, есть ли этот флаг, он для каждого свойства вызывает внутренний метод <code>[[GetOwnProperty]]</code>, который получает его дескриптор. В данном случае свойство отсутствует, его дескриптор пуст, флага <code>enumerable</code> нет, поэтому оно пропускается.</p>
                                    <p>Чтобы <code>Object.keys</code> возвращал свойство, нужно либо чтобы свойство в объекте физически было (с флагом <code>enumerable</code>), либо перехватить вызовы <code>[[GetOwnProperty]]</code> (с помощью ловушки <code>getOwnPropertyDescriptor</code>), и там вернуть дескриптор с <code>enumerable: true</code>.</p>
                                    <code class="large">let user = {};

user = new Proxy(user, {
    ownKeys(target) {  // вызывается 1 раз для получения списка свойств
        return ['a', 'b', 'c'];
    },

    getOwnPropertyDescriptor(target, prop) {  // вызывается для каждого свойства
        return {
            enumerable: true,
            configurable: true,
        };
    }
});

console.log( Object.keys(user) ); // ['a', 'b', 'c']</code>
                                    <h4>Защищённые свойства с ловушкой «deleteProperty» и другими</h4>
                                    <p>Существует широко распространённое соглашение о том, что свойства и методы, название которых начинается с символа подчёркивания <code>_</code>, следует считать внутренними. К ним не следует обращаться снаружи объекта.</p>
                                    <p>Поскольку технически это всё равно возможно, применим прокси, чтобы защитить свойства, начинающиеся на <code>_</code>, от доступа извне.</p>
                                    <code class="large">let user = {
    name: "Вася",
    _password: "***",
};

user = new Proxy(user, {
    get(target, prop) {
        if (prop.startsWith('_')) throw new Error('Отказано из [[Get]]');

        let value = target[prop];
        return typeof value === 'function' ? value.bind(target) : value;
    },
    set(target, prop, value) {
        if (prop.startsWith('_')) throw new Error('Отказано из [[Set]]');

        target[prop] = value;
        return true;
    },
    deleteProperty(target, prop) {
        if (prop.startsWith('_')) throw new Error('Отказано из [[Delete]]');

        delete target[prop];
        return true;
    },
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'));
    }
});

console.log(user._password); // Error: Отказано из [[Get]]
user._password = "test"; // Error: Отказано из [[Set]]
delete user._password; // Error: Отказано из [[Delete]]
for (let key in user) console.log(key); // name</code>
                                    <p>Метод самого объекта, например <code>user.checkPassword()</code>, должен иметь доступ к свойству <code>_password</code>:</p>
                                    <code class="large">checkPassword() { return this._password === '***' }</code>
                                    <p>Поэтому он привязывается к оригинальному объекту <code>target: value.bind(target)</code>. Дальнейшие вызовы будут происходить без всяких ловушек.</p>
                                    <p>Такое решение обычно работает, но, поскольку, метод может передать оригинальный объект куда-то ещё, возможна путаница: где изначальный объект, а где – проксированный. К тому же, объект может проксироваться несколько раз для добавления новых возможностей, и если передавать методу исходный, то могут быть неожиданности.</p>
                                    <h4>«В диапазоне» с ловушкой «has»</h4>
                                    <p>Предположим, есть объект range, описывающий диапазон:</p>
                                    <code class="large">let range = {
    start: 1,
    end: 10
};</code>
                                    <p>Мы бы хотели использовать оператор <code>in</code>, чтобы проверить, что некоторое число находится в указанном диапазоне.</p>
                                    <code class="large">range = new Proxy(range, {
    has(target, prop) {
        return prop >= target.start && prop &lt;= target.end;
    }
});

console.log(2 in range); // true</code>
                                    <h4>Оборачиваем функции: «apply»</h4>
                                    <p>Можно оборачивать в прокси и функции.</p>
                                    <p>Ловушка <code>apply(target, thisArg, args)</code> активируется при вызове прокси как функции:</p>
                                    <p><code>target</code> – оригинальный объект (функция).</p>
                                    <p><code>thisArg</code> – это контекст <code>this</code>.</p>
                                    <p><code>args</code> – список аргументов.</p>
                                    <p>Вспомним декоратор <code>delay(f, ms)</code>:</p>
                                    <code class="large">function delay(f, ms) {
    return function() {
        setTimeout(() => f.apply(this, arguments), ms);
    };
}

function sayHi(user) {
    console.log(`Привет, ${user}!`);
}

sayHi = delay(sayHi, 2000);

sayHi("Вася"); // Привет, Вася! (через 2 секунды)</code>
                                    <p>Функция-обёртка вызывает нужную функцию с указанной задержкой. Но она не перенаправляет операции чтения/записи свойства и другие. После обёртывания доступ к свойствам оригинальной функции, таким как <code>name</code>, <code>length</code>, и другим, будет потерян.</p>
                                    <code class="large">console.log(sayHi.length); // 1
sayHi = delay(sayHi, 2000);
console.log(sayHi.length); // 0</code>
                                    <p>Используем прокси вместо функции-обёртки:</p>
                                    <code class="large">function delay(f, ms) {
    return new Proxy(f, {
        apply(target, thisArg, args) {
            setTimeout(() => target.apply(thisArg, args), ms);
        }
    });
}

function sayHi(user) {
    console.log(`Привет, ${user}!`);
}

sayHi = delay(sayHi, 2000);
console.log(sayHi.length); // 1

sayHi("Вася"); // Привет, Вася! (через 2 секунды)</code>
                                    <p>Теперь не только вызовы, но и другие операции на прокси перенаправляются к оригинальной функции.</p>
                                    <h4>Reflect</h4>
                                    <p><code>Reflect</code> – встроенный объект, упрощающий создание прокси.</p>
                                    <p><code>Reflect</code> делает возможным обращение к внутренним методам, таким как <code>[[Get]]</code>, <code>[[Set]]</code> напрямую. Его методы – минимальные обёртки вокруг внутренних методов.</p>
                                    <div class="ibg ibg30">
                                        <img src="img/JS/Разное/Proxy/Методы Reflect.PNG" alt="Методы Reflect">
                                    </div>
                                    <code class="large">let user = {};
Reflect.set(user, 'name', 'Вася');
console.log(user.name); // Вася</code>
                                    <p>Для каждого внутреннего метода, перехватываемого <code>Proxy</code>, есть соответствующий метод в <code>Reflect</code>, который имеет такое же имя и те же аргументы, что и у ловушки <code>Proxy</code>.</p>
                                    <p>Можно использовать <code>Reflect</code>, чтобы перенаправить операцию на исходный объект.</p>
                                    <p>В этом примере обе ловушки <code>get</code> и <code>set</code> прозрачно (как будто их нет) перенаправляют операции чтения и записи на объект, при этом выводя сообщение:</p>
                                    <code class="large">let user = { name: "Вася" };

user = new Proxy(user, {
    get(target, prop, receiver) {
        console.log(`GET ${prop}`);
        return Reflect.get(target, prop, receiver);
    },
    set(target, prop, val, receiver) {
        console.log(`SET ${prop}=${val}`);
        return Reflect.set(target, prop, val, receiver);
    }
});

let name = user.name; // GET name
user.name = "Петя"; // SET name=Петя</code>
                                    <p><code>Reflect.get</code> читает свойство объекта.</p>
                                    <p><code>Reflect.set</code> записывает свойство и возвращает <code>true</code> при успехе, иначе <code>false</code>.</p>
                                    <p>То есть, если ловушка хочет перенаправить вызов на объект, достаточно вызвать <code>Reflect.&lt;метод></code> с теми же аргументами.</p>
                                    <h5>Прокси для геттера</h5>
                                    <p>Допустим, есть объект <code>user</code> со свойством <code>_name</code> и геттером для него. Сделаем вокруг <code>user</code> прокси. Ловушка <code>get</code> «прозрачная», она возвращает свойство исходного объекта и больше ничего не делает.</p>
                                    <p>Если унаследовать от проксированного <code>user</code> объект <code>admin</code>, увидим, что тот ведёт себя некорректно:</p>
                                    <code class="large">let user = {
    _name: "Гость",
    get name() {
        return this._name;
    }
};

let userProxy = new Proxy(user, {
    get(target, prop, receiver) {
        return target[prop];
    }
});

let admin = {
    __proto__: userProxy,
    _name: "Админ"
};

console.log(admin.name); // Гость</code>
                                    <p>Обращение к свойству <code>admin.name</code> должно возвращать строку <code>"Админ"</code>, а выводит <code>"Гость"</code>!</p>
                                    <p>Проблема в прокси. При чтении <code>admin.name</code>, так как в объекте <code>admin</code> нет свойства <code>name</code>, оно ищется в прототипе. Прототипом является прокси <code>userProxy</code>. При чтении из прокси свойства <code>name</code> срабатывает ловушка <code>get</code> и возвращает его из исходного объекта как <code>target[prop]</code>. Вызов <code>target[prop]</code>, если <code>prop</code> – это геттер, запускает его код в контексте <code>this=target</code>.</p>
                                    <p>Для исправления таких ситуаций и нужен <code>receiver</code>. В нём хранится ссылка на правильный контекст <code>this</code>, который нужно передать геттеру. Сделать это позволяет <code>Reflect.get</code>.</p>
                                    <code class="large">let user = {
    _name: "Гость",
    get name() {
        return this._name;
    }
};

let userProxy = new Proxy(user, {
    get(target, prop, receiver) {
        return Reflect.get(...arguments);
    }
});


let admin = {
    __proto__: userProxy,
    _name: "Админ"
};

console.log(admin.name); // Админ</code>
                                    <p>Сейчас <code>receiver</code>, содержащий ссылку на корректный <code>this</code> (то есть на <code>admin</code>), передаётся геттеру посредством <code>Reflect.get</code>.</p>
                                    <p><code>return Reflect...</code> даёт простую и безопасную возможность перенаправить операцию на оригинальный объект и при этом предохраняет от возможных ошибок, связанных с этим действием.</p>
                                    <h4>Ограничения прокси</h4>
                                    <p>Прокси – уникальное средство для настройки поведения объектов на самом низком уровне. Но есть некоторые ограничения.</p>
                                    <h5>Встроенные объекты: внутренние слоты</h5>
                                    <p>Многие встроенные объекты, например <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>Promise</code> и другие, за исключением <code>Array</code>, используют так называемые «внутренние слоты».</p>
                                    <p>Например, <code>Map</code> хранит элементы во внутреннем слоте <code>[[MapData]]</code>. Встроенные методы обращаются к слотам напрямую, не через <code>[[Get]]</code>/<code>[[Set]]</code>. Таким образом, прокси не может перехватить их.</p>
                                    <p>Если встроенный объект проксируется, то в прокси не будет этих «внутренних слотов» и попытка вызвать на таком прокси встроенный метод приведёт к ошибке.</p>
                                    <code class="large">let map = new Map();
let proxy = new Proxy(map, {});
proxy.set('test', 1); // TypeError: Method Map.prototype.set called on incompatible receiver #&lt;Map></code>
                                    <p>Встроенный метод <code>Map.prototype.set</code> пытается получить доступ к своему внутреннему свойству <code>this.[[MapData]]</code>, но так как <code>this=proxy</code>, то не может его найти.</p>
                                    <p>К счастью, есть способ исправить это:</p>
                                    <code class="large">let map = new Map();

let proxy = new Proxy(map, {
    get(target, prop, receiver) {
        let value = Reflect.get(...arguments);
        return typeof value == 'function' ? value.bind(target) : value;
    }
});

proxy.set('test', 1);
console.log(proxy.get('test')); // 1</code>
                                    <p>Всё сработало, потому что <code>get</code> привязывает свойства-функции, такие как <code>map.set</code>, к оригинальному объекту <code>map</code>. Таким образом, когда реализация метода <code>set</code> попытается получить доступ к внутреннему слоту <code>this.[[MapData]]</code>, то всё пройдёт благополучно.</p>
                                    <h5>Приватные поля</h5>
                                    <p>Нечто похожее происходит и с приватными полями классов, так как приватные поля реализованы с использованием внутренних слотов.</p>
                                    <code class="large">class User {
    #name = "Гость";

    getName() {
        return this.#name;
    }
}

let user = new User();
user = new Proxy(user, {});

console.log(user.getName()); // TypeError: Cannot read private member #name from an object whose class did not declare it</code>
                                    <p>В вызове <code>getName()</code> значением <code>this</code> является проксированный <code>user</code>, в котором нет внутреннего слота с приватными полями.</p>
                                    <p>Решением, как и в предыдущем случае, является привязка контекста к методу.</p>
                                    <h5>Прокси != оригинальный объект</h5>
                                    <p>Прокси не перехватывают проверку на строгое равенство <code>===</code>.</p>
                                    <p>Так что все операции и встроенные классы, которые используют строгую проверку объектов на равенство, отличат прокси от изначального объекта.</p>
                                    <h4>Отключаемые прокси</h4>
                                    <p>Отключаемый (revocable) прокси – это прокси, который может быть отключён вызовом специальной функции.</p>
                                    <p>Допустим, у нас есть какой-то ресурс, и мы бы хотели иметь возможность закрыть к нему доступ в любой момент.</p>
                                    <p>Для этого можем использовать отключаемый прокси, без ловушек. Такой прокси будет передавать все операции на проксируемый объект, и у нас будет возможность в любой момент отключить это.</p>
                                    <code class="large">let {proxy, revoke} = Proxy.revocable(target, handler)</code>
                                    <p>Вызов возвращает объект с <code>proxy</code> и функцией <code>revoke</code>, которая отключает его.</p>
                                    <code class="large">let object = { data: "Важные данные" };

let {proxy, revoke} = Proxy.revocable(object, {});

console.log(proxy.data); // Важные данные
revoke();
console.log(proxy.data); // TypeError: Cannot perform 'get' on a proxy that has been revoked</code>
                                    <p>Вызов <code>revoke()</code> удаляет все внутренние ссылки на оригинальный объект из прокси и оригинальный объект теперь может быть очищен сборщиком мусора.</p>
                                    <p>Мы можем хранить функцию <code>revoke</code> в <code>WeakMap</code>, чтобы легко найти её по объекту прокси:</p>
                                    <code class="large">let revokes = new WeakMap();

let object = { data: "Важные данные" };

let {proxy, revoke} = Proxy.revocable(object, {});

revokes.set(proxy, revoke);

revoke = revokes.get(proxy);
revoke();

console.log(proxy.data); // TypeError...</code>
                                    <p>Если прокси объект становится недостижимым, то <code>WeakMap</code> позволяет сборщику мусора удалить его из памяти вместе с соответствующей функцией <code>revoke</code>, которая в этом случае больше не нужна.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="bitwise-operators" class="chapter__title">Побитовые операторы</h3>
                                </div>
                                <div class="chapter__content">
                                    <p>Побитовые операторы работают следующим образом:</p>
                                    <ol>
                                        <li>Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть отбрасывается.</li>
                                        <li>Каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда. Оператор применяется к каждой паре бит.</li>
                                        <li>Получившаяся в результате последовательность бит интерпретируется как обычное число.</li>
                                    </ol>
                                    <p>Все побитовые операторы:</p>
                                    <ul>
                                        <li><code>a & b</code> - побитовое И. Результат <code>a & b</code> равен единице только когда оба бита <code>a</code> и <code>b</code> равны единице.</li>
                                        <li><code>a | b</code> - побитовое ИЛИ. Результат <code>a | b</code> равен <code>1</code>, если хотя бы один бит из <code>a</code> и <code>b</code> равен <code>1</code>.</li>
                                        <li><code>a ^ b</code> - побитовое исключающее ИЛИ. <code>a ^ b</code> равно <code>1</code>, если <code>a</code> и <code>b</code> противоположны.</li>
                                        <li><code>~a</code> - побитовое НЕ. Заменяет каждый бит операнда на противоположный.</li>
                                        <li><code>a &lt;&lt; b</code> - левый сдвиг. Сдвигает двоичное представление <code>a</code> на <code>b</code> битов влево, добавляя справа нули.</li>
                                        <li><code>a >> b</code> - правый сдвиг. Сдвигает двоичное представление <code>a</code> на <code>b</code> битов вправо, отбрасывая сдвигаемые биты. Знак числа сохраняется.</li>
                                        <li><code>a >>> b</code> - сдвиг вправо без знака. Это правый сдвиг с заполнением нулями слева.</li>
                                    </ul>
                                    <p>Для неотрицательных чисел операторы <code>>>></code> и  <code>>></code> дадут одинаковый результат, т.к. в обоих случаях слева добавятся нули.</p>
                                    <p>Побитовые операторы <code>^</code>, <code>&</code>, <code>|</code> имеют низкий приоритет и выполняются после сравнений <code>==</code>.</p>
                                    <h5>Отрицательные числа в двоичном представлении</h5>
                                    <p>Крайний левый бит двоичного числа называется знаковым. Если он равен <code>0</code> – число положительное, если <code>1</code> – число отрицательное.</p>
                                    <p>Для того, чтобы сделать из положительного числа отрицательное и наоборот, все биты числа инвертируются, после чего прибавляется единица.</p>
                                    <h4>Применение побитовых операторов</h4>
                                    <h5>Округление</h5>
                                    <p>Так как битовые операции отбрасывают десятичную часть, их можно использовать для округления вместо <code>Math.floor</code>:</p>
                                    <code class="large">console.log( ~~12.845 ); // 12</code>
                                    <p>Подойдёт и исключающее ИЛИ (<code>^</code>) с нулём:</p>
                                    <code class="large">console.log( 12.845 ^ 0 ); // 12</code>
                                    <h5>Исключающее ИЛИ ^</h5>
                                    <p>Исключающее ИЛИ можно использовать для шифрования, так как эта операция полностью обратима. То есть, выполняется формула <code>a ^ b ^ b === a</code>.</p>
                                    <code class="large">console.log(4921 ^ 708 ^ 708); // 4921</code>
                                    <h5>Побитовое НЕ ~</h5>
                                    <p>Обращение (инвертирование) битов – это побитовое НЕ (<code>~</code>). То есть, при таком формате представления числа <code>-n = ~n + 1</code>. Или, если перенести единицу:</p>
                                    <code class="large">~n = -(n+1)</code>
                                    <p>Побитовое НЕ <code>~</code> позволяет осуществлять проверку на <code>-1</code>, так как <code>~n === 0</code> только если <code>n === -1</code>.</p>
                                    <p>Проверка на <code>-1</code> пригождается, например, при поиске символа в строке:</p>
                                    <code class="large">let str = 'Проверка';

if (~str.indexOf('верка')) { // str.indexOf("верка") !== -1
    console.log('найдено');
}</code>
                                    <h5>Битовые маски</h5>
                                    <p>Битовое представление числа иногда используется для упаковки нескольких значений («флагов») в одно. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором <code>&</code>.</p>
                                    <p>Например, в проекте могут быть различные роли: админ, редактор и гость. Каждой роли соответствует ряд доступов к статьям и функциональности сайта.</p>
                                    <p>Как правило, доступы задаются в виде констант:</p>
                                    <code class="large">const ACCESS_ADMIN = 1; // 00001
const ACCESS_GOODS_EDIT = 2; // 00010
const ACCESS_GOODS_VIEW = 4; // 00100
const ACCESS_ARTICLE_EDIT = 8; // 01000
const ACCESS_ARTICLE_VIEW = 16; // 10000</code>
                                    <p>Из этих констант получить нужную комбинацию доступов можно при помощи операции <code>|</code>.</p>
                                    <code class="large">const guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW; // 10100
const editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT; // 11110
const admin = editor | ACCESS_ADMIN; // 11111</code>
                                    <p>Теперь, чтобы понять, имеет ли <code>guest</code> нужный доступ, например управление правами – достаточно применить к нему побитовый оператор И (<code>&</code>) с соответствующей константой. Ненулевой результат будет означать, что доступ есть:</p>
                                    <code class="large">console.log(guest & ACCESS_ADMIN); // 0
console.log(editor & ACCESS_ARTICLE_EDIT); // 8</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="bigint" class="chapter__title">BigInt</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>BigInt</code> – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.</p>
                                    <p>Чтобы создать значение типа <code>BigInt</code>, необходимо добавить <code>n</code> в конец числового литерала или вызвать функцию <code>BigInt</code>, которая создаст число типа <code>BigInt</code> из переданного аргумента. Аргументом может быть число, строка и др.</p>
                                    <code class="large">console.log(BigInt('10') === 10n); // true</code>
                                    <h4>Математические операторы</h4>
                                    <p>К числам типа <code>bigint</code> можно применять математические операторы. Все операции возвращают целое число, округленное в меньшее сторону.</p>
                                    <code class="large">console.log(8n / 3n); // 2n</code>
                                    <p>Смешивать <code>bigint</code> и обычные числа нельзя.</p>
                                    <code class="large">1n + 2; // TypeError: Cannot mix BigInt and other types, use explicit conversions</code>
                                    <p>Необходимо их явно конвертировать одним из способов:</p>
                                    <code class="large">console.log(1n + BigInt(2)); // 3n
console.log(Number(1n) + 2); // 3</code>
                                    <h4>Операции сравнения</h4>
                                    <p>Сравнивать <code>bigint</code> и <code>number</code> числа можно:</p>
                                    <code class="large">console.log( 2n > 1 ); // true
console.log( 1 == 1n ); // true</code>
                                    <h4>Логические операции</h4>
                                    <p>Логические операторы работают с <code>bigint</code> как с обычными числами:</p>
                                    <code class="large">console.log( 1n || 2 ); // 1n
console.log( 0n || 2 ); // 2</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="intl" class="chapter__title">Intl: интернационализация в JavaScript</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>Intl.Collator</code> - умеет правильно сравнивать и сортировать строки.</p>
                                    <p><code>Intl.DateTimeFormat</code> - умеет форматировать дату и время в соответствии с нужным языком.</p>
                                    <p><code>Intl.NumberFormat</code> - умеет форматировать числа в соответствии с нужным языком.</p>
                                    <h4>Локаль</h4>
                                    <p>Локаль – первый аргумент всех методов, связанных с интернационализацией. Описывается строкой из трёх (обычно меньше) компонентов, которые разделяются дефисом:</p>
                                    <ol>
                                        <li>Код языка.</li>
                                        <li>Код способа записи.</li>
                                        <li>Код страны.</li>
                                    </ol>
                                    <p><code>ru</code> – русский язык, без уточнений.</p>
                                    <p><code>en-GB</code> – английский язык, используемый в Англии.</p>
                                    <p><code>en-US</code> – английский язык, используемый в США.</p>
                                    <p>Если локаль не указана или <code>undefined</code> – берётся локаль по умолчанию, установленная в окружении (браузере).</p>
                                    <h4>Строки, Intl.Collator</h4>
                                    <p><code>let collator = new Intl.Collator([locales, [options]])</code> - создание</p>
                                    <p><code>collator.compare(str1, str2)</code> - метод для сравнения</p>
                                    <ul>
                                        <li><code>1</code> если <code>str1 > str2</code></li>
                                        <li><code>-1</code> если <code>str1 &lt; str2</code></li>
                                        <li><code>0</code> если <code>str2 == str2</code></li>
                                    </ul>
                                    <p><code>locales</code> - локаль, одна или массив в порядке предпочтения.</p>
                                    <p><code>options</code> - объект с дополнительными настройками:</p>
                                    <ul>
                                        <li><code>sensitivity</code> – чувствительность к различию символов.
                                            <ul>
                                                <li><code>'base'</code> – <code>е == ё</code>, <code>а == А</code></li>
                                                <li><code>'accent'</code> – <code>е != ё</code>, <code>а == А</code></li>
                                                <li><code>'case'</code> – <code>е == ё</code>, <code>а != А</code></li>
                                                <li>[<code>'variant'</code>] – <code>е != ё</code>, <code>а != А</code></li>
                                            </ul>
                                        </li>
                                        <li><code>ignorePunctuation</code> – игнорирование знаков пунктуации.
                                            <ul>
                                                <li><code>true</code> – игнорировать знаки пунктуации и пробелы</li>
                                                <li>[<code>false</code>] – знаки пунктуации имеют значение</li>
                                            </ul>
                                        </li>
                                        <li><code>numeric</code> – применять численное сравнение.
                                            <ul>
                                                <li><code>true</code> – применять (<code>12 > 2</code>)</li>
                                                <li>[<code>false</code>] – игнорировать (<code>12 &lt; 2</code>)</li>
                                            </ul>
                                        </li>
                                        <li><code>caseFirst</code> – при сортировке определяет, прописные или строчные буквы идут первыми.
                                            <ul>
                                                <li><code>'upper'</code> – прописные</li>
                                                <li><code>'lower'</code> – строчные</li>
                                            </ul>
                                        </li>
                                    </ul>
                                    <code class="large">let collator = new Intl.Collator(undefined, {
    sensitivity: "accent"
});

console.log( collator.compare("ЁжиК", "ёжик") ); // 0
</code>
                                    <h4>Даты, Intl.DateTimeFormat</h4>
                                    <p><code>let formatter = new Intl.DateTimeFormat([locales, [options]])</code> - создание</p>
                                    <p><code>let dateString = formatter.format(date)</code> - форматирование</p>
                                    <p><code>options</code> - объект, который может иметь следующие свойства:</p>
                                    <ul>
                                        <li><code>hour12</code> – двенадцатичасовой формат – <code>true</code>/<code>false</code></li>
                                        <li><code>weekday</code> – обозначение дня недели – <code>narrow</code>/<code>short</code>/<code>long</code></li>
                                        <li><code>era</code> – эра – <code>narrow</code>/<code>short</code>/<code>long</code></li>
                                        <li><code>year</code> – <code>2-digit</code>/<code>numeric</code></li>
                                        <li><code>month</code> – <code>2-digit</code>/<code>numeric</code>/<code>narrow</code>/<code>short</code>/<code>long</code></li>
                                        <li><code>day</code> – <code>2-digit</code>/<code>numeric</code></li>
                                        <li><code>hour</code> – <code>2-digit</code>/<code>numeric</code></li>
                                        <li><code>minute</code> – <code>2-digit</code>/<code>numeric</code></li>
                                        <li><code>second</code> – <code>2-digit</code>/<code>numeric</code></li>
                                    </ul>
                                    <p>Значения свойств:</p>
                                    <p><code>'narrow'</code> – одна заглавная буква.</p>
                                    <p><code>'short'</code> – две или три буквы.</p>
                                    <p><code>'long'</code> – целое слово.</p>
                                    <p><code>'numeric'</code> – число, может совпадать с <code>2-digit</code>.</p>
                                    <p><code>'2-digit'</code> – две цифры.</p>
                                    <code class="large">let formatter = new Intl.DateTimeFormat('ru', {
    year: '2-digit',
    month: '2-digit',
    day: '2-digit',
});

console.log( formatter.format( new Date() ) ); // 07.07.23</code>
                                    <h4>Числа, Intl.NumberFormat</h4>
                                    <p><code>let formatter = new Intl.NumberFormat([locales[, options]])</code> - создание</p>
                                    <p><code>formatter.format(number)</code> - форматирование</p>
                                    <p><code>options</code> - объект, который может иметь следующие свойства:</p>
                                    <ul>
                                        <li><code>style</code> – cтиль форматирования – [<code>decimal</code>], <code>percent</code>, <code>currency</code></li>
                                        <li><code>currency</code> – алфавитный код валюты (<code>RUB</code>, <code>USD</code> и тд)</li>
                                        <li><code>currencyDisplay</code> – как отображать валюту – [<code>symbol</code>], <code>code</code>,  <code>name</code></li>
                                        <li><code>useGrouping</code> – разделение цифр по три – [<code>true</code>], <code>false</code></li>
                                        <li><code>minimumFractionDigits</code> – минимальное число десятичных цифр – от <code>0</code> до <code>20</code></li>
                                        <li><code>maximumFractionDigits</code> – максимальное число десятичных цифр – от <code>minimumFractionDigits</code> до <code>20</code></li>
                                        <li><code>minimumSignificantDigits</code> – минимальное число значимых цифр – от <code>1</code> до <code>21</code></li>
                                        <li><code>maximumSignificantDigits</code> – максимальное число значимых цифр – от <code>minimumSignificantDigits</code> до <code>21</code></li>
                                    </ul>
                                    <code class="large">let formatter1 = new Intl.NumberFormat("ru", { maximumSignificantDigits: 3 });
console.log( formatter1.format(1234567890.123) ); // 1 230 000 000

let formatter2 = new Intl.NumberFormat("ru", {
    style: "currency",
    currency: "GBP"
});
  
console.log( formatter2.format(1234.5) ); // 1 234,50 £</code>
                                    <h4>Методы в Date, String, Number</h4>
                                    <p>Все эти методы при запуске создают соответствующий объект <code>Intl.*</code> и передают ему опции, можно рассматривать их как укороченные варианты вызова.</p>
                                    <p><code>str1.localeCompare(str2 [, locales [, options]])</code> - сравнивает строки с учетом локали.</p>
                                    <p><code>date.toLocaleString([locales [, options]])</code> - форматирует дату с учетом локали.</p>
                                    <p><code>date.toLocaleDateString([locales [, options]])</code> - имеет <code>year</code>, <code>month</code>, <code>day</code> по умолчанию.</p>
                                    <p><code>date.toLocaleTimeString([locales [, options]])</code> - имеет <code>hour</code>, <code>minute</code>, <code>second</code> по умолчанию.</p>
                                    <code class="large">console.log( new Date().toLocaleTimeString() ); // 09:21:05</code>
                                    <p><code>num.toLocaleString([locales [, options]])</code> - форматирует число с учетом локали.</p>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="binary" class="chapter__title">Бинарные данные и файлы</h3>
                                </div>
                                <div class="chapter__content">
                                    <h4>ArrayBuffer, бинарные массивы</h4>
                                    <p>Базовый объект для работы с бинарными данными представляет собой ссылку на непрерывную область памяти фиксированной длины:</p>
                                    <code class="large">let buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт
console.log(buffer.byteLength); // 16</code>
                                    <p>Для работы с <code>ArrayBuffer</code> нужен специальный объект, реализующий «представление» данных.</p>
                                    <p><code>Uint8Array</code> – представляет каждый байт в <code>ArrayBuffer</code> как отдельное число («8-битное целое без знака»). Возможные значения - от <code>0</code> до <code>255</code>.</p>
                                    <p><code>Uint16Array</code> – представляет каждые 2 байта как целое число. Значения от <code>0</code> до <code>65535</code>.</p>
                                    <p><code>Uint32Array</code> – представляет каждые 4 байта как целое число. Значения от <code>0</code> до <code>4294967295</code>.</p>
                                    <p><code>Float64Array</code> – представляет каждые 8 байт как число с плавающей точкой. Значения от <code>5e-324</code> до <code>1.8e308</code>.</p>
                                    <p><code>Uint8ClampedArray</code> - отличается от <code>Uint8Array</code> тем, что значения больше <code>255</code> представлены числом <code>255</code>, отрицательные - нулем.</p>
                                    <p>Есть и другие: <code>BigUint64Array</code> (числа от <code>0</code> до <code>2^64 - 1</code>), <code>BigInt64Array</code>, <code>Float32Array</code>, <code>Int8Array</code> (числа от <code>-128</code> до <code>-127</code>), <code>Int16Array</code>, <code>Int32Array</code>.</p>
                                    <p>При выходе за пределы значений (если это не <code>Uint8ClamedArray</code>) лишние старшие биты будут отброшены:</p>
                                    <code class="large">let buffer = new ArrayBuffer(16);
let uint8array = new Uint8Array(buffer);

console.log((256).toString(2)); // 100000000
uint8array[0] = 256;
console.log(uint8array[0]); // 0

console.log(Uint8Array.BYTES_PER_ELEMENT); // 1
console.log(uint8array.length); // 16
console.log(uint8array.byteLength); // 16
</code>
                                    <h5>TypedArray</h5>
                                    <p>Это общий термин для всех таких представлений (<code>Uint8Array</code>, <code>Uint32Array</code> и т.д.).</p>
                                    <p>Есть 5 вариантов создания типизированных массивов:</p>
                                    <p><code>new TypedArray(buffer, [byteOffset], [length])</code> - типизированный массив длиной <code>buffer.byteLength / TypedArray.BYTES_PER_ELEMENT</code>.</p>
                                    <p><code>new TypedArray(arrayLike)</code> - пустой типизированный массив длиной <code>arrayLike.length</code> с содержимым псевдомассива <code>arrayLike</code>.</p>
                                    <p><code>new TypedArray(typedArray)</code> - типизированный массив той же длины с содержимым <code>typedArray</code>. При необходимости значения приводятся к новому типу.</p>
                                    <p><code>new TypedArray(length)</code> - типизированный массив длины <code>length</code>.</p>
                                    <p><code>new TypedArray()</code> - пустой типизированный массив.</p>
                                    <p><code>ArrayBuffer</code> создаётся автоматически во всех случаях, кроме первого. Для доступа к <code>ArrayBuffer</code> в <code>TypedArray</code> есть следующие свойства:</p>
                                    <p><code>buffer</code> – ссылка на объект <code>ArrayBuffer</code>.</p>
                                    <p><code>byteLength</code> – размер содержимого <code>ArrayBuffer</code> в байтах.</p>
                                    <h5>Методы TypedArray</h5>
                                    <p>Типизированные массивы <code>TypedArray</code>, имеют те же методы, что и массивы <code>Array</code>. Исключения: <code>splice</code>, <code>concat</code>.</p>
                                    <p>Имеются 2 дополнительных метода:</p>
                                    <p><code>arr.set(fromArr, [offset])</code> - копирует все элементы из <code>fromArr</code> в <code>arr</code>, начиная с позиции <code>offset</code> (<code>0</code> по умолчанию).</p>
                                    <p><code>arr.subarray([begin, end])</code> - создаёт новое представление того же типа для данных, начиная с позиции <code>begin</code> до (не включая) <code>end</code>.</p>
                                    <h5>DataView</h5>
                                    <p><code>DataView</code> – это специальное нетипизированное представление данных из <code>ArrayBuffer</code>. Оно позволяет обращаться к данным на любой позиции и в любом формате. Синтаксис:</p>
                                    <code class="large">new DataView(buffer, [byteOffset], [byteLength])</code>
                                    <p><code>buffer</code> – ссылка на бинарные данные <code>ArrayBuffer</code>.</p>
                                    <p><code>byteOffset</code> – начальная позиция данных для представления (по умолчанию <code>0</code>).</p>
                                    <p><code>byteLength</code> – длина данных (в байтах), используемых в представлении (по умолчанию – до конца <code>buffer</code>).</p>
                                    <code class="large">let uint8Array = new Uint8Array([255, 255, 255, 255]);
let dataView = new DataView(uint8Array.buffer);
console.log( dataView.getUint8(0) ); // 255
console.log( dataView.getUint16(0) ); // 65535
console.log( dataView.getUint32(0) ); // 4294967295
dataView.setUint32(0, 0); // во все 4 байта записаны нули
console.log(uint8Array); // [0, 0, 0, 0];</code>
                                    <p>Представление <code>DataView</code> отлично подходит для получения доступа к данным разного формата в одном буфере.</p>
                                    <h4>TextDecoder и TextEncoder</h4>
                                    <p><code>let decoder = new TextDecoder([label], [options])</code> - объект, позволяющий декодировать данные из бинарного буфера в обычную строку.</p>
                                    <p><code>label</code> – кодировка (<code>utf-8</code> по умолчанию).</p>
                                    <p><code>options</code> – объект с дополнительными настройками.</p>
                                    <ul>
                                        <li><code>fatal</code> – [<code>false</code>] / <code>true</code>. Если <code>true</code>, генерируется ошибка для невалидных (не декодируемых) символов, иначе (по умолчанию) они заменяются символом <code>\uFFFD</code>.</li>
                                        <li><code>ignoreBOM</code> – [<code>false</code>] / <code>true</code>. Если <code>true</code>, тогда игнорируется BOM (дополнительный признак, определяющий порядок следования байтов).</li>
                                    </ul>
                                    <code class="large">let str = decoder.decode([input], [options]);</code>
                                    <p><code>input</code> – бинарный буфер <code>BufferSource</code> (бинарные данные в любом виде) для декодирования.</p>
                                    <p><code>options</code> – объект с дополнительными настройками.</p>
                                    <ul>
                                        <li><code>stream</code> – [<code>false</code>] / <code>true</code>. Если <code>true</code>, <code>TextDecoder</code> запоминает символ, на котором остановился процесс, и декодирует его со следующим фрагментом.</li>
                                    </ul>
                                    <code class="large">let uint8Array = new Uint8Array([72, 101, 108, 108, 111]);
console.log( new TextDecoder().decode(uint8Array) ); // Hello</code>
                                    <p><code>let encoder = new TextEncoder()</code> - объект, кодирующий строку в бинарный массив. Поддерживается только кодировка <code>utf-8</code>. Имеет два метода:</p>
                                    <p><code>encode(str)</code> – возвращает бинарный массив <code>Uint8Array</code>, содержащий закодированную строку.</p>
                                    <p><code>encodeInto(str, destination)</code> – кодирует строку <code>str</code> и помещает её в <code>destination</code>, который должен быть экземпляром <code>Uint8Array</code>.</p>
                                    <code class="large">let encoder = new TextEncoder();
console.log(encoder.encode("Hello")); // [72, 101, 108, 108, 111]</code>
                                    <h4>Blob</h4>
                                    <p><code>new Blob(blobParts, options)</code> - создание объекта <code>Blob</code>.</p>
                                    <p><code>blobParts</code> – массив значений <code>Blob</code>/<code>BufferSource</code>/<code>String</code>.</p>
                                    <p><code>options</code> – необязательный объект с дополнительными настройками:</p>
                                    <ul>
                                        <li><code>type</code> – тип объекта, обычно MIME-тип, например, <code>image/png</code></li>
                                        <li><code>endings</code> – если указан, изменяет окончания строк создаваемого <code>Blob</code></li>
                                    </ul>
                                    <code class="large">let blob1 = new Blob(["<html>…</html>"], {type: 'text/html'});

let hello = new Uint8Array([72, 101, 108, 108, 111]);
let blob2 = new Blob([hello, ' ', 'world'], {type: 'text/plain'});</code>
                                    <p>Данные в <code>Blob</code> неизменяемы (immutable), но можно делать срезы и создавать новый <code>Blob</code> на их основе.</p>
                                    <p><code>blob.slice([byteStart], [byteEnd], [contentType])</code> - делает срез <code>Blob</code>.</p>
                                    <p><code>byteStart</code> – стартовая позиция байта, по умолчанию <code>0</code>.</p>
                                    <p><code>byteEnd</code> – последний байт, по умолчанию до конца.</p>
                                    <p><code>contentType</code> – тип <code>type</code> создаваемого <code>Blob</code>-объекта, по умолчанию такой же, как и исходный.</p>
                                    <h5>Blob как URL</h5>
                                    <p><code>URL.createObjectURL(blob)</code> - создает уникальный URL в формате <code>blob</code>.</p>
                                    <p>Для каждого URL, сгенерированного через <code>URL.createObjectURL</code>, браузер сохраняет внутреннее соответствие URL → <code>Blob</code>.</p>
                                    <p><code>URL.revokeObjectURL(url)</code> - удаляет внутреннюю ссылку на объект, что позволяет (если нет другой ссылки) удалить его сборщику мусора, и очистить память.</p>
                                    <p>Пример: при клике загружается динамически генерируемый <code>blob</code> (.txt) с текстом "Hello, world!".</p>
                                    <p>HTML: <code>&lt;a download="hello.txt" href='#' id="link">Загрузить&lt;/a></code></p>
                                    <code class="large">let blob = new Blob(["Hello, world!"], {type: 'text/plain'});
link.href = URL.createObjectURL(blob);</code>
                                    <p>Пример: автозагрузка ссылка с эмуляцией клика.</p>
                                    <code class="large">let link = document.createElement('a');
link.download = 'hello.txt';
let blob = new Blob(['Hello, world!'], {type: 'text/plain'});
link.href = URL.createObjectURL(blob);
link.click();
URL.revokeObjectURL(link.href);</code>
                                    <h5>Изображение в Blob</h5>
                                    <p>canvas-метод <code>.toBlob(callback, format, quality)</code> создаёт <code>Blob</code> и вызывает функцию <code>callback</code> при завершении.</p>
                                    <p>Можно создать <code>Blob</code> для изображения, части изображения или даже создать скриншот страницы. Операции с изображениями выполняются через элемент &lt;canvas>. Для отрисовки изображения (или его части) используется <code>canvas.drawImage</code>.</p>
                                    <p>Пример: изображение копируется и загружается.</p>
                                    <code class="large">let img = document.querySelector('img');
let canvas = document.createElement('canvas');
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

let context = canvas.getContext('2d');
context.drawImage(img, 0, 0);

canvas.toBlob(function(blob) {
    let link = document.createElement('a');
    link.download = 'example.png';

    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
}, 'image/png');</code>
                                    <p>Или <code>async</code>/<code>await</code> вместо колбэка:</p>
                                    <code class="large">let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));</code>
                                    <h5>Из Blob в ArrayBuffer</h5>
                                    <p>Если нужна производительная низкоуровневая обработка, можно использовать <code>ArrayBuffer</code> из <code>FileReader</code>:</p>
                                    <code class="large">let fileReader = new FileReader();

fileReader.readAsArrayBuffer(blob);

fileReader.onload = function(event) {
    let arrayBuffer = fileReader.result;
};</code>
                                </div>
                            </section>
                            <section class="content__chapter chapter">
                                <div class="chapter__header">
                                    <h3 data-title="fetch" class="chapter__title">Fetch</h3>
                                </div>
                                <div class="chapter__content">
                                    <p><code>let promise = fetch(url, [options])</code> - современный метод сделать сетевой запрос.</p>
                                    <p><code>url</code> – URL для отправки запроса.</p>
                                    <p><code>options</code> – дополнительные параметры: метод, заголовки и так далее. Если не указаны, это простой GET-запрос, скачивающий содержимое по адресу <code>url</code>.</p>
                                    <p>Результатом запроса становится объект встроенного класса <code>Response</code>.</p>
                                    <p><code>response.status</code> – код статуса HTTP-запроса, например 200.</p>
                                    <p><code>response.ok</code> – логическое значение: будет <code>true</code>, если код HTTP-статуса в диапазоне 200-299.</p>
                                    <p>Для получения тела ответа необходимо использовать дополнительный вызов метода. Выбрать можно только один метод чтения ответа.</p>
                                    <p><code>response.text()</code> – читает ответ и возвращает как обычный текст.</p>
                                    <p><code>response.json()</code> – декодирует ответ в формате JSON.</p>
                                    <p><code>response.formData()</code> – возвращает ответ как объект <code>FormData</code>.</p>
                                    <p><code>response.blob()</code> – возвращает объект как <code>Blob</code>.</p>
                                    <p><code>response.arrayBuffer()</code> – возвращает ответ как <code>ArrayBuffer</code>.</p>
                                    <code class="large">fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
    .then(response => response.json())
    .then(commits => console.log(commits[0].author.login)); // iliakan</code>
                                    <h5>Заголовки ответа</h5>
                                    <p>Заголовки ответа хранятся в похожем на <code>Map</code> объекте <code>response.headers</code>.</p>
                                    <code class="large">fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
    .then(response => {
        console.log( Object.fromEntries(response.headers) ); // {cache-control: 'public, max-age=60, s-maxage=60', content-type: ...
        console.log( response.headers.get('content-type') ); // application/json; charset=utf-8
    })</code>
                                    <h5>Заголовки запроса</h5>
                                    <p>Для установки заголовка запроса в <code>fetch</code> можно использовать опцию <code>headers</code>. Она содержит объект с исходящими заголовками.</p>
                                    <code class="large">let response = fetch(protectedUrl, {
    headers: {
        Authentication: 'secret'
    }
});</code>
                                    <p>Некоторые HTTP-заголовки нельзя установить. Они обеспечивают достоверность данных и корректную работу протокола HTTP, поэтому контролируются исключительно браузером.</p>
                                    <p>Для отправки POST-запроса или запроса с другим методом, необходимо использовать <code>fetch</code> параметры.</p>
                                    <p><code>method</code> – HTTP метод, например <code>POST</code>.</p>
                                    <p><code>body</code> – тело запроса, одно из списка:</p>
                                    <ul>
                                        <li>строка (например, в формате JSON)</li>
                                        <li>объект <code>FormData</code> для отправки данных как <code>form/multipart</code></li>
                                        <li><code>Blob</code>/<code>BufferSource</code> для отправки бинарных данных</li>
                                        <li><code>URLSearchParams</code> для отправки данных в кодировке <code>x-www-form-urlencoded</code>, используется редко</li>
                                    </ul>
                                    <code class="large">let user = {
    name: 'John',
    surname: 'Smith'
};
  
let response = await fetch('/article/fetch/post/user', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json;charset=utf-8'
    },
    body: JSON.stringify(user)
});
  
let result = await response.json();
console.log(result.message);</code>
                                    <p>Поскольку тело запроса <code>body</code> – строка, заголовок <code>Content-Type</code> по умолчанию будет <code>text/plain;charset=UTF-8</code>. Но, так как мы посылаем JSON, нужно поставить правильный <code>Content-Type</code> для JSON.</p>
                                </div>
                            </section>
                        </div>
                    </section>
                </div>
            </div>
        </main>
    </div>

</body>
</html>